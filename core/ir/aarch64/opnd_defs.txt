# **********************************************************
# Copyright (c) 2016-2022 ARM Limited. All rights reserved.
# **********************************************************

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of ARM Limited nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL ARM LIMITED OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

# Data read by "codec.py" and used to generate some C source files.
# After changing this file, run "codec.py" in this directory.

# Text from '#' to the end of the line is a comment.

################################################################################
# Operand types

# The syntax here is: mask opndtype

# Each operand type is listed here with a mask, consisting of '-', '?', 'x',  '+' and
# '^', showing how the bits are used by the encoder/decoder functions,
# {de,en}code_opnd_OPNDTYPE, in "codec.c". The operands are ordered by pattern.
#
# '-' : Bit is not handled by operand encoder or decoder.
# '?' : Bit is read by encoder and decoder but not generated by encoder.
# 'x' : Bit is read by decoder and generated by encoder.
# '+' : As 'x', but at least one of the bits marked must be set
# '^' : Bit is allowed to vary by the spec, but by default is set to 1 by the encoder
#
# Thus an operand encoder may generate a bit that is read by another operand
# encoder, but it is an error if there is a cyclic dependency.
#
# Note that the operands should be in alphabetical order (of the mask.)
# The order of the operand implementation functions in codec.c should match the
# order in this file.

# Hints for understanding the operand type names:
# In register operands (e.g. w10) the number refers to the position of the lowest bit.
# In memory operands (e.g. mem7) the number refers to the number of offset bits.

# Notes on specific operands:
# - cmode_* implements both cmode3 and cmode4 as defined in the specification.
#   cmode size  amounts
#   1110  8(b)  0
#   10x0  16(h) 0,8
#   0xx0  32(s) 0,8,16,24
#   110x  32(s) 8,16 (MSL, shifting ones)

--------------------------------  impx16     # implicit X16 operand
--------------------------------  impx17     # implicit X17 operand
--------------------------------  impx30     # implicit X30 operand
--------------------------------  impsp      # implicit SP operand
--------------------------------  lsl        # implicit LSL for ADD/MOV (immediate)
--------------------------------  mul        # implicit MUL
--------------------------------  h_sz       # element width of FP vector reg, used to
                                             # distinguish FP16 and float/double encs
--------------------------------  b_const_sz # as above, but for byte width
--------------------------------  h_const_sz # as above, but for half width
--------------------------------  s_const_sz # as above, but for single width
--------------------------------  d_const_sz # as above, but for double width
--------------------------------  vindex_D1  # An implicit index, at index 1
--------------------------------  zero_fp_const # A constant zero operand
----------------------------xxxx  nzcv       # flag bit specifier for CCMN, CCMP, RMIF
----------------------------xxxx  p0         # SVE predicate registers p0-p15
----------------------------xxxx  p_b_0      # P register with a byte element size
----------------------------xxxx  p_h_0      # P register with a halfword element size
----------------------------xxxx  prfop4     # prefetch operation
---------------------------xxxxx  w0         # W register (or WZR)
---------------------------xxxxx  w0p0       # even-numbered W register (or WZR)
---------------------------xxxxx  w0p1       # ... add 1
---------------------------xxxxx  x0         # X register (or XZR)
---------------------------xxxxx  x0sp       # X register (or SP)
---------------------------xxxxx  memx0      # X register used as memref for SYS
---------------------------xxxxx  x0p0       # even-numbered X register (or XZR)
---------------------------xxxxx  x0p1       # ... add 1
---------------------------xxxxx  b0         # B register
---------------------------xxxxx  h0         # H register
---------------------------xxxxx  s0         # S register
---------------------------xxxxx  d0         # D register
---------------------------xxxxx  q0         # Q register
---------------------------xxxxx  z0         # Z register
---------------------------xxxxx  z_b_0      # Z register with b size elements
---------------------------xxxxx  z_h_0      # Z register with h size elements
---------------------------xxxxx  z_s_0      # Z register with s size elements
---------------------------xxxxx  z_d_0      # Z register with d size elements
---------------------------xxxxx  z_q_0      # Z register with q size elements
---------------------------xxxxx  q0p1       # Q register, add 1
---------------------------xxxxx  q0p2       # Q register, add 2
---------------------------xxxxx  q0p3       # Q register, add 3
---------------------------xxxxx  prfop      # prefetch operation
--------------------------x-----  fpimm1_half_one_5 # 1 bit floating-point index, represents 0.5 or 1.0
--------------------------x-----  fpimm1_zero_one_5 # 1 bit floating-point index, represents 0.0 or 1.0
--------------------------x-----  fpimm1_half_two_5 # 1 bit floating-point index, represents 0.5 or 2.0
------------------------xx------  imm2_6     # 2 bit immediate from 6-7
------------------------xxx-----  op2        # 3 bit immediate from 5-7
-----------------------xxxx-----  p_b_5      # P register with a byte element size
-----------------------xxxx-----  p5         # P register
-----------------------xxxx-----  p5_zer     # P register, zeroing
----------------------xxxxx-----  w5         # W register (or WZR)
----------------------xxxxx-----  x5         # X register (or XZR)
----------------------xxxxx-----  x5sp       # X register or XSP
----------------------xxxxx-----  b5         # B register
----------------------xxxxx-----  h5         # H register
----------------------xxxxx-----  s5         # S register
----------------------xxxxx-----  d5         # D register
----------------------xxxxx-----  q5         # Q register
----------------------xxxxx-----  z5         # Z register
----------------------xxxxx-----  z_b_5      # Z register with b size elements
----------------------xxxxx-----  z_h_5      # Z register with h size elements
----------------------xxxxx-----  z_s_5      # Z register with s size elements
----------------------xxxxx-----  z_d_5      # Z register with d size elements
----------------------xxxxx-----  z_q_5      # Z register with q size elements
----------------------xxxxx-----  mem9qpost  # size is 16 bytes; post-index
----------------------xxxxx-----  pred_constr  # pattern operand
----------------------xxxxx-----  simm5_5    # Signed 5 bit immediate from 5 - 9
---------------------x----------  imm1_ew_10 # 1 bit symbolised imm, representing 90 or 270
---------------------xxxxxx-----  simm6_5    # Signed 6 bit immediate from 5 - 10
--------------------xx----------  vmsz       # B/H/S/D for load/store multiple structures
--------------------xx----------  imm2_nesw_10 # 2 bit symbolised imm, representing 0, 90, 180, or 270
--------------------xxxx--------  imm4       # option for CLREX, DSB, DMB, ISB, MSR
                                             # CRm field for SYS and SYSL
-------------------x------------  cmode4_s_sz_msl # MSL bit for 32 bit element shifts
-------------------x------------  imm1_ew_12   # 1 bit symbolised imm, representing 90 or 270
-------------------xx-----------  imm2_nesw_11 # 2 bit symbolised imm, representing 0, 90, 180, or 270
-------------------xxx----------  extam      # extend amount
-------------------xxx----------  p10_lo     # SVE predicate registers p0-p7
-------------------xxx----------  p10_zer_lo # SVE predicate registers p0-p7, zeroing
-------------------xxx----------  p10_mrg_lo # SVE predicate registers p0-p7, merging
-------------------xxxxxxxx-----  imm8_5     # 8 bit imm at pos 5
-------------------xxxxxxxx-----  simm8_5    # signed 8 bit imm at pos 5
------------------x-------------  cmode_h_sz # Vector shift for 16 bit elements
------------------x-------------  shift1     # LSL #0 or #8 depending on bit 13
------------------xx------------  imm2idx    # imm from 13-12, used as an index
------------------xxxx----------  p10        # SVE predicate registers p0-p15
------------------xxxx----------  p10_mrg    # SVE predicate registers p0-p15, merging
------------------xxxx----------  p10_zer    # SVE predicate registers p0-p15, zeroing
------------------xxxx----------  imm4_10 # 4 bit immediate from 10:13
-----------------xx-------------  cmode_s_sz # Vector shift for 32 bit elements
-----------------xx-------------  imm2_nesw_13 # 2 bit symbolised imm, representing 0, 90, 180, or 270
-----------------xx-------------  len        # imm2 len
-----------------xxxx-----------  imm4idx    # imm4 from 11-14
-----------------xxxxx----------  w10        # W register (or WZR)
-----------------xxxxx----------  x10        # X register (or XZR)
-----------------xxxxx----------  s10        # S register
-----------------xxxxx----------  d10        # D register
-----------------xxxxx----------  q10        # Q register
----------------????------------  cmode4_b_sz # Vector shift for byte elements
----------------xxx-------------  ext        # extend type
----------------xxxx------------  crn        # 4 bit immediate from 12-15
----------------xxxx------------  cond       # condition for CCMN, CCMP
----------------xxxxxx----------  scale      # encoding of #fbits value in scale field
----------------xxxxxxxxxxxxxxxx  imm16_0    # imm16 at position 0
---------------x----------------  imm1_ew_16 # 1 bit symbolised imm, representing 90 or 270
--------------?------??????xxxxx  z_imm13_bhsd_0 # sve vector reg, elsz depending on size value encoded within an 13 bit immediate from 5-17
--------------xxxxxxxxxxxxx-----  imm13_const # Const value within a 13 bit immediate from 5-17
-------------xx------------xxxxx  z_size17_hsd_0 # z register with the size determined by bits 17-18
-------------xx-------xxxxx-----  z_size17_hsd_5 # z register with the size determined by bits 17-18
-------------xxx----------------  imm3       # 3 bit immediate from 16-18
-------------xxx----------------  z3_b_16    # Z0-7 register with b size elements at position 16
-------------xxx----------------  z3_h_16    # Z0-7 register with h size elements at position 16
-------------xxx----------------  z3_s_16    # Z0-7 register with s size elements at position 16
-------------xxx--------xxx-----  pstate     # Pstate encoded in op1:op2
-------------xxx------xxxxx-----  fpimm8     # floating-point immediate for vector fmov
-------------xxx------xxxxx-----  imm8       # immediate from 16:18 and 5:9
-------------xxx------xxxxx-----  exp_imm8   # expanded immediate from 16:18 and 5:9
------------xxxx----------------  p16_mrg    # merging P register at position 16
------------xxxx----------------  p16_zer    # zeroing P register at position 16
------------xxxx----------------  p_b_16     # P register with a byte element size at position 16
------------xxxx----------------  imm4_16p1  # 4bit imm at 19-16, plus 1
------------xxxx----------------  z4_h_16     # Z0-15 register with h size elements at position 16
------------xxxx----------------  z4_s_16     # Z0-15 register with s size elements at position 16
------------xxxx----------------  z4_d_16     # Z0-15 register with d size elements at position 16
------------xxxx----------------  q4_16       # Q0-15 register at position 16
------------xxxxxxxxxxxxxxx-----  sysreg     # operand of MRS
-----------?????----------------  bh_imm5_sz # Size encoded as least significant bit in imm5
-----------?????----------------  bhs_imm5_sz # Size encoded as least significant bit in imm5
-----------?????----------------  bhsd_imm5_sz # Size encoded as least significant bit in imm5
-----------?????-----------xxxxx  z_tsz_bhsdq_0   # Z register with size encoded in tsz field
-----------?????------xxxxx-----  z_tsz_bhsdq_5   # Z register with size encoded in tsz field
-----------?????------xxxxx-----  wx5_imm5   # reg 5-9 d or q is inferred from bits 16:20
-----------x--------------------  i1_index_20 # Index value from 20
-----------x--------x-----------  i2_index_11 # Index value from 20,11
-----------xx-------------------  i2_index_19 # Index value from 20:19
-----------xx-------x-----------  i3_index_11 # Index value from 20:19,11
-----------xxxxx----------------  imm5       # 5 bit immediate from 16-20
-----------xxxxx----------------  simm5      # Signed 5 bit immediate from 16-20
-----------xxxxx----------------  bhs_imm5_sz_s # Size encoded as least significant bit in imm5
-----------xxxxx----------------  bhsd_imm5_sz_s # Size encoded as least significant bit in imm5
-----------xxxxx----------------  imm5_idx   # Index from imm5
-----------xxxxx----------------  w16        # W register (or WZR)
-----------xxxxx----------------  w16p0      # even-numbered W register (or WZR)
-----------xxxxx----------------  w16p1      # ... add 1
-----------xxxxx----------------  x16        # X register (or XZR)
-----------xxxxx----------------  x16sp      # X register (or SP)
-----------xxxxx----------------  x16p0      # even-numbered X register (or XZR)
-----------xxxxx----------------  x16p1      # ... add 1
-----------xxxxx----------------  d16        # D register
-----------xxxxx----------------  q16        # Q register
-----------xxxxx----------------  z_b_16     # Z register with b size elements
-----------xxxxx----------------  z_h_16     # Z register with h size elements
-----------xxxxx----------------  z_s_16     # Z register with h size elements
-----------xxxxx----------------  z_d_16     # Z register with d size elements
-----------xxxxx----------------  z_q_16     # Z register with q size elements
-----------xxxxx----------------  b16        # B register
-----------xxxxx----------------  h16        # H register
-----------xxxxx----------------  s16        # S register
-----------xxxxx---xxx----------  imm8_10    # 8 bit imm at pos 10, split across 20:16 and 12:10
-----------xxxxx-??---xxxxx-----  sveprf_gpr_vec64 # SVE prefetch memory address (64-bit offset) [<Xn|SP>, <Zm>.D{, <mod> <amount>}]
-----------xxxxxx---------------  imm6_15    # 6 bit immediate from 20:15
-----------xxxxxxx--------------  imm7       # 7 bit immediate from 20:14
-----------xxxxxxxxx------------  mem9off     # immed offset for mem9/mem9post
-----------xxxxxxxxx------------  mem9off_tag # Same as mem9off, but performs memory tag scaling
-----------xxxxxxxxx--xxxxx-----  mem9q      # size is 16 bytes
-----------xxxxxxxxx--xxxxx-----  mem9_ldg_tag # Same as mem9_tag but fixed at offset with 0 bytes transferred
-----------xxxxxxxxx--xxxxx-----  prf9       # size is 0 bytes (prefetch variant of mem9)
-----------xxxxxxxxx--xxxxx-----  memregq    # register offset, size is 16 bytes
-----------xxxxxxxxx--xxxxx-----  prfreg     # register offset, size is 0 (prefetch)
-----------xxxxxxxxxxxxxxxx-----  imm16      # immediate for MOVK/MOVN/MOVZ/SVC
----------?-------?-xxxxxxx-----  memvr      # gets size from 21, 13 and 11:10
----------?-----???-??xxxxx-----  memvs      # gets size from 21, 15:13 and 11:10
----------?xxxxx--?-??----------  x16immvr   # computes immed from 21, 13 and 11:10
----------?xxxxx???-??----------  x16immvs   # computes immed from 21, 15:13 and 11:10
----------x----------------xxxxx  z_sz21_sd_0  # SVE vector reg, elsz depending on bit 21
----------x---------x-----------  vindex_S   # Index for vector with single
----------xx--------x-----------  vindex_H   # Index for vector with half elements (0-7)
----------xxxxxx----------------  imm6_16_tag # 6 bit immediate from 16:21 with tagged memory scaling
----------xxxxxx------xxxxx-----  svemem_gpr_simm6_vl # imm offset and base reg for SVE
----------xxxxxx------xxxxx-----  svememx6_b_5    # vector memory reg with 6 bit imm for byte value
----------xxxxxx------xxxxx-----  svememx6_h_5    # vector memory reg with 6 bit imm for half value
----------xxxxxx------xxxxx-----  svememx6_s_5    # vector memory reg with 6 bit imm for single value
----------xxxxxx------xxxxx-----  svememx6_d_5    # vector memory reg with 6 bit imm for double value
----------xxxxxx-?-xxxxxxxx-----  svemem_gpr_simm9_vl # imm offset and base reg for SVE ld/st
----------xxxxxxx---------------  mem7off_tag # Same as mem7off, but performs memory tag scaling
----------xxxxxxxxxxxx----------  imm12      # immediate for ADD/SUB
----------xxxxxxxxxxxxxxxxx-----  mem12q     # size is 16 bytes
----------xxxxxxxxxxxxxxxxx-----  prf12      # size is 0 bytes (prefetch variant of mem12)
---------????-------------------  hsd_immh_sz  # encoding of vector element size in immh field
---------????-------------------  bhsd_immh_sz # encoding of vector element size in immh field
---------????--------------xxxxx  hsd_immh_reg0    # hsd register, depending on immh field
---------????--------------xxxxx  bhsd_immh_reg0   # bhsd register, depending on immh field
---------????---------xxxxx-----  hsd_immh_reg5    # hsd register, depending on immh field
---------????---------xxxxx-----  bhsd_immh_reg5   # bhsd register, depending on immh field
---------?x---------x-----------  vindex_SD        # Index for vector with single or double
---------?x---------x-----------  vindex_HS_2lane  # Index for vector with half or single, using 2 lanes
---------x----------------------  imm12sh    # shift for ADD/SUB (immediate); '0x'
                                             # elements, depending on bit 22 (sz)
---------x----------------------  sd_sz      # element width of FP vector reg for single or double
---------x----------------------  hs_fsz      # element width of FP vector reg for half or single
---------x-----------------xxxxx  z_sz_sd    # SVE vector reg, elsz depending on sz
---------x------------xxxxx-----  dq5_sz     # as dqx, but depending on the sz bit rather than the Q bit
---------x------------xxxxx-----  wx_sz_5    # W/X register (or WZR/XZR) with size indicated in bit 22
---------x-xx-------------------  i3_index_19 # Index value from 22, 20:19
---------x-xx--------------xxxxx  z_wtszl19_bhsd_0 # z element register mediated by the tszl and tszh fields, writing out the size
---------x-xx---------xxxxx-----  z_wtszl19p1_bhsd_5 # z element register mediated by the tszl and tszh fields, writing out the size, plus 1
---------x-xxxxx----------------  wx_sz_16   # W/X register (or WZR/XZR) with size indicated in bit 22
---------x-xxxxx----------------  tszl19lo_imm3_16   # imm constructed from imm3 and some bits of tsz
---------x-xxxxx----------------  tszl19lo_imm3_16p1 # imm constructed from imm3 and some bits of tsz, plus 1
---------x-xxxxxxxxx------------  mem_s_imm9_off # The offset part of memory address reg+offset mem_s_imm9
---------xx----------------xxxxx  z_size21_hsd_0  # sve vector reg, elsz depending on size21
---------xx----------------xxxxx  z_size21_bhsd_0  # sve vector reg, elsz depending on size21
---------++++xxx----------------  immhb_shf  # encoding of #shift value in immh:immb fields
---------++++xxx----------------  immhb_0shf # encoding of #shift value in zero-indexed immh:immb fields
---------++++xxx----------------  immhb_fxp  # encoding of #fbits value in immh:immb fields
--------??-----------------xxxxx  wx_size_0_zr # GPR scalar register, register size, W or X depending on size bits
--------??------------??---xxxxx  z_tszl8_bhsd_0 # z element register mediated by the tszl and tszh fields
--------??------------xxxxx-----  wx_size_5_sp # GPR scalar register, register size, W or X depending on size bits
--------??------------xxxxx-----  wx_size_5_zr # GPR scalar register, register size, W or X depending on size bits
--------??------------xxxxx-----  z_tb_bhs_5 # sve vector reg, elsz depending on size Tb
--------??----------??xxxxx-----  mem9post_tag   # Same as mem9_tag but specifically post-indexed
--------??---------xxxxxxxx-----  fpimm8_5   # floating-point 8 bit imm at pos 5
--------??-??--------------xxxxx  z_tszl19_bhsd_0 # z element register mediated by the tszl and tszh fields
--------??-??--------------xxxxx  z_tszl19_bhs_0 # z element register mediated by the tszl and tszh fields
--------??-??--------------xxxxx  z_tszl19p1_hsd_0 # z element register mediated by the tszl and tszh fields, plus 1
--------??-??---------xxxxx-----  z_tszl19_bhsd_5 # z element register mediated by the tszl and tszh fields
--------??-??---------xxxxx-----  z_tszl19_bhs_5  # z element register mediated by the tszl and tszh fields
--------??-??---------xxxxx-----  z_tszl19p1_hsd_5 # z element register mediated by the tszl and tszh fields
--------??-xxxxx----------------  wx_size_16_zr # GPR scalar register, register size, W or X depending on size bits
--------??-xxxxx----xxxxxxx-----  svemem_vec_vec_idx # SVE memory address [<Zn>.<T>, <Zm>.<T>{, <mod> <amount>}]
--------??-xxxxxxxx-------------  fpimm8_13  # floating-point immediate for scalar fmov
--------??-xxxxxxxxx??xxxxx-----  mem9_tag       # Write bytes is in 23:22, post/pre/offset is in 11:10, with memory tag scaling
--------xx----------------------  b_sz       # element width of a vector (8<<b_sz)
--------xx----------------------  hs_sz      # element width of a vector (8<<hs_sz)
--------xx----------------------  bhs_sz     # element width of a vector (8<<bhs_sz)
--------xx----------------------  bhsd_sz    # element width of a vector (8<<bhsd_sz)
--------xx----------------------  bd_sz      # element width of a vector (8<<bd_sz)
--------xx----------------------  shift3     # shift type for add/sub (shifted register)
--------xx----------------------  shift4     # shift type for logical (shifted register)
--------xx------------------xxxx  p_size_bhsd_0    # sve predicate vector reg, elsz depending on size
--------xx------------------xxxx  p_size_bhs_0     # sve predicate vector reg, elsz depending on size
--------xx------------------xxxx  p_size_bh_0      # sve predicate vector reg, elsz depending on size
--------xx------------------xxxx  p_size_hsd_0     # sve predicate vector reg, elsz depending on size
--------xx-----------------xxxxx  float_reg0       # H, S or D register
--------xx-----------------xxxxx  hsd_size_reg0    # hsd register, depending on size opcode
--------xx-----------------xxxxx  bhsd_size_reg0   # bhsd register, depending on size opcode
--------xx-----------------xxxxx  z_size_bhsd_0    # sve vector reg, elsz depending on size
--------xx-----------------xxxxx  z_size_bhs_0     # sve vector reg, elsz depending on size
--------xx-----------------xxxxx  z_sizep1_bhs_0   # sve vector reg, elsz depending on size, plus one
--------xx-----------------xxxxx  z_size_hsd_0     # sve vector reg, elsz depending on size
--------xx-----------------xxxxx  z_size_sd_0      # sve vector reg, elsz depending on size
--------xx-----------------xxxxx  z_size_hd_0      # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  float_reg5       # H, S or D register
--------xx------------xxxxx-----  hsd_size_reg5    # hsd register, depending on size opcode
--------xx------------xxxxx-----  bhsd_size_reg5   # bhsd register, depending on size opcode
--------xx------------xxxxx-----  p_size_bhsd_5    # sve predicate vector reg, elsz depending on size
--------xx------------xxxxx-----  p_size_hsd_5     # sve predicate vector reg, elsz depending on size
--------xx------------xxxxx-----  z_size_bhsd_5    # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  z_size_bhsd_5p1  # sve vector reg, elsz depending on size, plus 1
--------xx------------xxxxx-----  z_size_bhs_5     # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  z_size_bh_5      # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  z_sizep1_bhs_5   # sve vector reg, elsz depending on size, plus 1
--------xx------------xxxxx-----  z_sizep2_bh_5    # sve vector reg, elsz depending on size, plus 2
--------xx------------xxxxx-----  z_sizep1_bs_5    # sve vector reg, elsz depending on size, plus 1
--------xx------------xxxxx-----  z_size_hsd_5     # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  z_size_sd_5      # sve vector reg, elsz depending on size
--------xx------------xxxxx-----  tszl8_imm3_5     # imm constructed from imm3 and some bits of tsz
--------xx------------xxxxx-----  tszl8_imm3_5p1   # imm constructed from imm3 and some bits of tsz, plus 1
--------xx-------xxxxx----------  float_reg10 # H, S or D register
--------xx-xxxxx----------------  float_reg16 # H, S or D register
--------xx-xxxxx----------------  tszl19_imm3_16   # imm constructed from imm3 and some bits of tsz
--------xx-xxxxx----------------  tszl19_imm3_16p1 # imm constructed from imm3 and some bits of tsz, plus 1
--------xx-xxxxx----------------  hsd_size_reg16   # hsd register, depending on size opcode
--------xx-xxxxx----------------  bhsd_size_reg16  # bhsd register, depending on size opcode
--------xx-xxxxx----------------  p_size_bhsd_16   # sve vector reg, elsz depending on size
--------xx-xxxxx----------------  z_size_bhsd_16   # sve vector reg, elsz depending on size
--------xx-xxxxx----------------  z_size_bh_16     # sve vector reg, elsz depending on size
--------xx-xxxxx----------------  z_size_sd_16     # sve vector reg, elsz depending on size
--------xx-xxxxx----------------  z_sizep1_bhs_16  # sve vector reg, elsz depending on size plus 1
--------xx-xxxxx----------------  z_sizep2_bh_16   # sve vector reg, elsz depending on size plus 2
--------xx-xxxxx----------------  z_sizep1_bs_16   # sve vector reg, elsz depending on size plus 1
--------xx-xxxxx----------------  z_size_hsd_16    # sve vector reg, elsz depending on size
--------xx-xxxxx----------------  imm2_tsz_index   # Index encoded in imm2:tsz
-------??-------------xxxxx-----  mem7post_tag   # Same as mem7_tag but specifically post-indexed
-------??--xxxxx------xxxxx-----  svemem_vec_s_imm5 # SVE memory address [<Zn>.S{, #<imm>}]
-------??--xxxxx------xxxxx-----  svemem_vec_d_imm5 # SVE memory address [<Zn>.D{, #<imm>}]
-------??--xxxxx------xxxxx-----  sveprf_gpr_shf   # SVE memory address [<Xn|SP>, <Xm>, LSL #x] for prefetch operation
-------??--xxxxx------xxxxx-----  svemem_gpr_shf   # SVE memory address [<Xn|SP>, <Xm>, LSL #x]
-------??--xxxxx------xxxxx-----  svemem_gpr_shf_signed   # SVE memory address [<Xn|SP>, <Xm>, LSL #x] for signed load operations
-------??-?xxxxx------xxxxx-----  svemem_gpr_vec64 # SVE memory address (64-bit offset) [<Xn|SP>, <Zm>.D{, <mod>}]
-------??-xxxxxxx-----xxxxx-----  mem7_tag       # Write bytes is fixed at 16bytes, post/pre/offset is in 24:23, with memory tag scaling
-------???-xxxxx------xxxxx-----  svemem_vec_22sd_gpr16 # SVE memort operand [<Zn>.S/D{, <Xm>}]
-------????-xxxx------xxxxx-----  svemem_gpr_simm4_vl_1reg # SVE memory operand [<Xn|SP>{, #<imm>, MUL VL}]
                                                           # 1 src/dest register
-------????-xxxx------xxxxx-----  svemem_gpr_simm4_vl_xreg # SVE memory operand [<Xn|SP>{, #<imm>, MUL VL}]
                                                           # multiple src/dest registers or single non-temporals
-------????-xxxx------xxxxx-----  svemem_ssz_gpr_simm4 # SVE memory operand [<Xn|SP>{, #<imm>}],
                                                       # replicating loads
-------????xxxxx-x----xxxxx-----  svemem_gpr_vec32_st # SVE memory address (32-bit offset) [<Xn|SP>, <Zm>.<T>, <mod> <amount>]
-------xx------------------xxxxx  z_msz_bhsd_0    # z register with element size determined by msz
-------xx------------------xxxxx  z_msz_bhsd_0p1  # z register with element size determined by msz, plus 1
-------xx------------------xxxxx  z_msz_bhsd_0p2  # z register with element size determined by msz, plus 2
-------xx------------------xxxxx  z_msz_bhsd_0p3  # z register with element size determined by msz, plus 3
-------xx-------------xxxxx-----  z_msz_bhsd_5    # z register with element size determined by msz
-------xx----xxx----------------  z3_msz_bhsd_16  # z register with element size determined by msz, max z7
-------xx---xxxx----------------  z4_msz_bhsd_16  # z register with element size determined by msz, max z15
-------xx--xxxxx----------------  z_msz_bhsd_16   # z register with element size determined by msz
-?--------------------xxxxx-----  mem0p      # gets size from 30; no offset, pair
-?---------xxxxx????------------  x16imm     # computes immed from 30 and 15:12
-?-----??--xxxxx------xxxxx-----  svemem_vec_30sd_gpr16  # SVE memory address with GPR offset [<Zn>.S/D{, <Xm>}]
-x------------------------------  index3     # index of D subreg in Q: 0-1
-x-------------------------xxxxx  wx0_30     # X register if bit 30 is set, else W
-x-------------------------xxxxx  dq0        # Q register if bit 30 is set, else D
-x-------------------------xxxxx  sd0        # D register if bit 30 is set, else S
-x-------------------------xxxxx  dq0p1      # ... add 1
-x-------------------------xxxxx  dq0p2      # ... add 2
-x-------------------------xxxxx  dq0p3      # ... add 3
-x-------------------------xxxxx  vt0        # checks (30, 11:10) != (0, 0b11)
-x-------------------------xxxxx  vt1        # ... add 1
-x-------------------------xxxxx  vt2        # ... add 2
-x-------------------------xxxxx  vt3        # ... add 3
-x--------------------xxxxx-----  dq5        # Q register if bit 30 is set, else D
-x--------------------xxxxx-----  sd5        # D register if bit 30 is set, else S
-x-----------------x------------  index2     # index of S subreg in Q: 0-3
-x-----------------xx-----------  index1     # index of H subreg in Q: 0-7
-x-----------------xxx----------  index0     # index of B subreg in Q: 0-15
-x--------------????--xxxxx-----  memvm      # computes multiplier from 15:12
-x----------xxxx----------------  dq16_h_sz # Q register (0-15) if bit 30 is set, else D
-x----------xxxx----------------  sd16_h_sz # D register (0-15) if bit 30 is set, else S
-x---------xxxxx----------------  dq16       # Q register if bit 30 is set, else D
-x---------xxxxx----------------  sd16       # D register if bit 30 is set, else S
-x-------x-----------------xxxxx  vdq_q_sd_0  # Q register if bit 30 is set, else D. element size s or d
-x-------x------------xxxxx-----  vdq_q_sd_5  # Q register if bit 30 is set, else D. element size s or d
?---------------xxxxxx----------  imm6       # shift amount
?---------------xxxxxx----------  imms       # bitfield immediate, checks 31
?---------xxxxxx----------------  immr       # bitfield immediate, checks 31
?--------xx---------------------  imm16sh    # shift for MOVK/... (immediate); checks 31
??--------------------xxxxx-----  mem0       # gets size from 31:30; no offset
??--------------------xxxxx-----  mem9post   # gets size from 31:30; post-index
??---------xxxxxxxxx--xxxxx-----  mem9       # gets size from 31:30
??---------xxxxxxxxx--xxxxx-----  memreg     # register offset, gets size from 31:30
??--------xxxxxxxxxxxxxxxxx-----  mem12      # gets size from 31:30
??-------x-xxxxx-??---xxxxx-----  sveprf_gpr_vec32 # SVE prefetch memory address (32-bit offset) [<Xn|SP>, <Zm>.<T>, <mod>{ <amount>}]
??-------x-xxxxxxxxx?-xxxxx-----  mem_s_imm9 # Memory address reg+offset S:imm9, gets size from 31:30
??-----??x?xxxxx------xxxxx-----  svemem_gpr_vec32_ld # SVE memory address (32-bit offset) [<Xn|SP>, <Zm>.<T>, <mod> <amount>]
??---?----------------xxxxx-----  mem7post   # gets size from 31:30 and 26; post-index
??---?----xxxxxxx---------------  mem7off    # gets size from 31:30 and 26
??---?----xxxxxxx-----xxxxx-----  mem7       # gets size from 31:30 and 26
??---?--xxxxxxxxxxxxxxxxxxx-----  memlit     # load literal, gets size from 31:30 and 26
x--------------------------xxxxx  wx0        # W/X register (or WZR/XZR)
x--------------------------xxxxx  wx0sp      # W/X register or WSP/XSP
x---------------------xxxxx-----  wx5        # W/X register (or WZR/XZR)
x---------------------xxxxx-----  wx5sp      # W/X register or WSP/XSP
x----------------xxxxx----------  wx10       # W/X register (or WZR/XZR)
x----------xxxxx----------------  wx16       # W/X register (or WZR/XZR)
