# **********************************************************
# Copyright (c) 2016-2022 ARM Limited. All rights reserved.
# **********************************************************

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of ARM Limited nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL ARM LIMITED OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

# Data read by "codec.py" and used to generate some C source files.
# After changing this file, run "codec.py" in this directory.

# Text from '#' to the end of the line is a comment.

################################################################################
# Operand types

# The syntax here is: mask opndtype

# Each operand type is listed here with a mask, consisting of '-', '?', 'x',  '+' and
# '^', showing how the bits are used by the encoder/decoder functions,
# {de,en}code_opnd_OPNDTYPE, in "codec.c". The operands are ordered by pattern.
#
# '-' : Bit is not handled by operand encoder or decoder.
# '?' : Bit is read by encoder and decoder but not generated by encoder.
# 'x' : Bit is read by decoder and generated by encoder.
# '+' : As 'x', but at least one of the bits marked must be set
# '^' : Bit is allowed to vary by the spec, but by default is set to 1 by the encoder
#
# Thus an operand encoder may generate a bit that is read by another operand
# encoder, but it is an error if there is a cyclic dependency.

# Hints for understanding the operand type names:
# In register operands (e.g. w10) the number refers to the position of the lowest bit.
# In memory operands (e.g. mem7) the number refers to the number of offset bits.

# Notes on specific operands:
# - cmode_* implements both cmode3 and cmode4 as defined in the specification.
#   cmode size  amounts
#   1110  8(b)  0
#   10x0  16(h) 0,8
#   0xx0  32(s) 0,8,16,24
#   110x  32(s) 8,16 (MSL, shifting ones)

--------------------------------  impx30     # implicit X30 operand
--------------------------------  lsl        # implicit LSL for ADD/MOV (immediate)
--------------------------------  h_sz       # element width of FP vector reg, used to
                                             # distinguish FP16 and float/double encs
--------------------------------  b_const_sz # as above, but for byte width
--------------------------------  s_const_sz # as above, but for single width
--------------------------------  d_const_sz # as above, but for double width
--------------------------------  vindex_D1  # An implicit index, at index 1
----------------------------xxxx  nzcv       # flag bit specifier for CCMN, CCMP
---------------------------xxxxx  w0         # W register (or WZR)
---------------------------xxxxx  w0p0       # even-numbered W register (or WZR)
---------------------------xxxxx  w0p1       # ... add 1
---------------------------xxxxx  x0         # X register (or XZR)
---------------------------xxxxx  memx0      # X register used as memref for SYS
---------------------------xxxxx  x0p0       # even-numbered X register (or XZR)
---------------------------xxxxx  x0p1       # ... add 1
---------------------------xxxxx  b0         # B register
---------------------------xxxxx  h0         # H register
---------------------------xxxxx  s0         # S register
---------------------------xxxxx  d0         # D register
---------------------------xxxxx  q0         # Q register
---------------------------xxxxx  z0         # Z register
---------------------------xxxxx  q0p1       # Q register, add 1
---------------------------xxxxx  q0p2       # Q register, add 2
---------------------------xxxxx  q0p3       # Q register, add 3
---------------------------xxxxx  prfop      # prefetch operation
------------------------xxx-----  op2        # 3 bit immediate from 5-7
----------------------xxxxx-----  w5         # W register (or WZR)
----------------------xxxxx-----  x5         # X register (or XZR)
----------------------xxxxx-----  x5sp       # X register or XSP
----------------------xxxxx-----  b5         # B register
----------------------xxxxx-----  h5         # H register
----------------------xxxxx-----  s5         # S register
----------------------xxxxx-----  d5         # D register
----------------------xxxxx-----  q5         # Q register
----------------------xxxxx-----  z5         # Z register
----------------------xxxxx-----  mem9qpost  # size is 16 bytes; post-index
--------------------xx----------  vmsz       # B/H/S/D for load/store multiple structures
--------------------xxxx--------  imm4       # option for CLREX, DSB, DMB, ISB, MSR
-------------------x------------  cmode4_s_sz_msl # MSL bit for 32 bit element shifts
-------------------xxx----------  extam      # extend amount
------------------x-------------  cmode_h_sz # Vector shift for 16 bit elements
------------------xxxx----------  p10_low    # SVE predicate registers p0-p7
-----------------xx-------------  cmode_s_sz # Vector shift for 32 bit elements
-----------------xx-------------  len        # imm2 len
-----------------xxxx-----------  imm4idx    # imm4 from 11-14
-----------------xxxxx----------  w10        # W register (or WZR)
-----------------xxxxx----------  x10        # X register (or XZR)
-----------------xxxxx----------  s10        # S register
-----------------xxxxx----------  d10        # D register
-----------------xxxxx----------  q10        # Q register
----------------????------------  cmode4_b_sz # Vector shift for byte elements
----------------xxx-------------  ext        # extend type
----------------xxxx------------  crn        # 4 bit immediate from 12-15
----------------xxxx------------  cond       # condition for CCMN, CCMP
----------------xxxxxx----------  scale      # encoding of #fbits value in scale field
----------------xxxxxxxxxxxxxxxx  imm16_0    # imm16 at position 0
-------------xxx----------------  op1        # 3 bit immediate from 16-18
-------------xxx--------xxx-----  pstate     # Pstate encoded in op1:op2
-------------xxx------xxxxx-----  fpimm8     # floating-point immediate for vector fmov
-------------xxx------xxxxx-----  imm8       # immediate from 16:18 and 5:9
-------------xxx------xxxxx-----  exp_imm8   # expanded immediate from 16:18 and 5:9
-------------xxxxxxxxxxxxxx-----  sysops     # immediate operands for SYS
------------xxxxxxxxxxxxxxx-----  sysreg     # operand of MRS
-----------?????----------------  bh_imm5_sz # Size encoded as least significant bit in imm5
-----------?????----------------  bhs_imm5_sz # Size encoded as least significant bit in imm5
-----------?????----------------  bhsd_imm5_sz # Size encoded as least significant bit in imm5
-----------?????------xxxxx-----  wx5_imm5   # reg 5-9 d or q is inferred from bits 16:20
-----------xxxxx----------------  imm5       # immediate for CCMN, CCMP

-----------xxxxx----------------  bhs_imm5_sz_s # Size encoded as least significant bit in imm5
-----------xxxxx----------------  bhsd_imm5_sz_s # Size encoded as least significant bit in imm5
-----------xxxxx----------------  imm5_idx   # Index from imm5
-----------xxxxx----------------  w16        # W register (or WZR)
-----------xxxxx----------------  w16p0      # even-numbered W register (or WZR)
-----------xxxxx----------------  w16p1      # ... add 1
-----------xxxxx----------------  x16        # X register (or XZR)
-----------xxxxx----------------  x16p0      # even-numbered X register (or XZR)
-----------xxxxx----------------  x16p1      # ... add 1
-----------xxxxx----------------  d16        # D register
-----------xxxxx----------------  q16        # Q register
-----------xxxxx----------------  z16        # Z register
-----------xxxxx----------------  b16        # B register
-----------xxxxx----------------  h16        # H register
-----------xxxxx----------------  s16        # S register
-----------xxxxxxxxx------------  mem9off    # immed offset for mem9/mem9post
-----------xxxxxxxxx--xxxxx-----  mem9q      # size is 16 bytes
-----------xxxxxxxxx--xxxxx-----  prf9       # size is 0 bytes (prefetch variant of mem9)
-----------xxxxxxxxx--xxxxx-----  memregq    # register offset, size is 16 bytes
-----------xxxxxxxxx--xxxxx-----  prfreg     # register offset, size is 0 (prefetch)
-----------xxxxxxxxxxxxxxxx-----  imm16      # immediate for MOVK/MOVN/MOVZ/SVC
----------?-------?-xxxxxxx-----  memvr      # gets size from 21, 13 and 11:10
----------?-----???-??xxxxx-----  memvs      # gets size from 21, 15:13 and 11:10
----------?xxxxx--?-??----------  x16immvr   # computes immed from 21, 13 and 11:10
----------?xxxxx???-??----------  x16immvs   # computes immed from 21, 15:13 and 11:10
----------xx--------x-----------  vindex_H   # Index for vector with half elements (0-7)
----------xxxxxxxxxxxx----------  imm12      # immediate for ADD/SUB
----------xxxxxxxxxxxxxxxxx-----  mem12q     # size is 16 bytes
----------xxxxxxxxxxxxxxxxx-----  prf12      # size is 0 bytes (prefetch variant of mem12)
---------????-------------------  hsd_immh_sz  # encoding of vector element size in immh field
---------????-------------------  bhsd_immh_sz # encoding of vector element size in immh field
---------????--------------xxxxx  hsd_immh_reg0    # hsd register, depending on immh field
---------????--------------xxxxx  bhsd_immh_reg0   # bhsd register, depending on immh field
---------????---------xxxxx-----  hsd_immh_reg5    # hsd register, depending on immh field
---------????---------xxxxx-----  bhsd_immh_reg5   # bhsd register, depending on immh field
---------?x---------x-----------  vindex_SD  # Index for vector with single or double
---------x----------------------  imm12sh    # shift for ADD/SUB (immediate); '0x'
                                             # elements, depending on bit 22 (sz)
---------x----------------------  sd_sz      # element width of FP vector reg for single
---------x------------xxxxx-----  dq5_sz     # as dqx, but depending on the sz bit rather than the Q bit
---------++++xxx----------------  immhb_shf  # encoding of #shift value in immh:immb fields
---------++++xxx----------------  immhb_0shf # encoding of #shift value in zero-indexed immh:immb fields
---------++++xxx----------------  immhb_fxp  # encoding of #fbits value in immh:immb fields
--------??-xxxxxxxx-------------  fpimm13    # floating-point immediate for scalar fmov
--------xx----------------------  b_sz       # element width of a vector (8<<b_sz)
--------xx----------------------  hs_sz      # element width of a vector (8<<hs_sz)
--------xx----------------------  bhs_sz     # element width of a vector (8<<bhs_sz)
--------xx----------------------  bhsd_sz    # element width of a vector (8<<bhsd_sz)
--------xx----------------------  bd_sz      # element width of a vector (8<<bd_sz)
--------xx----------------------  shift3     # shift type for add/sub (shifted register)
--------xx----------------------  shift4     # shift type for logical (shifted register)
--------xx-----------------xxxxx  float_reg0  # H, S or D register
--------xx-----------------xxxxx  hsd_size_reg0    # hsd register, depending on size opcode
--------xx-----------------xxxxx  bhsd_size_reg0   # bhsd register, depending on size opcode
--------xx------------xxxxx-----  float_reg5  # H, S or D register
--------xx------------xxxxx-----  hsd_size_reg5    # hsd register, depending on size opcode
--------xx------------xxxxx-----  bhsd_size_reg5   # bhsd register, depending on size opcode
--------xx-------xxxxx----------  float_reg10 # H, S or D register
--------xx-xxxxx----------------  float_reg16 # H, S or D register
--------xx-xxxxx----------------  hsd_size_reg16   # hsd register, depending on size opcode
--------xx-xxxxx----------------  bhsd_size_reg16  # bhsd register, depending on size opcode
-?--------------------xxxxx-----  mem0p      # gets size from 30; no offset, pair
-?---------xxxxx????------------  x16imm     # computes immed from 30 and 15:12
-x------------------------------  index3     # index of D subreg in Q: 0-1
-x-------------------------xxxxx  dq0        # Q register if bit 30 is set, else D
-x-------------------------xxxxx  dq0p1      # ... add 1
-x-------------------------xxxxx  dq0p2      # ... add 2
-x-------------------------xxxxx  dq0p3      # ... add 3
-x-------------------------xxxxx  vt0        # checks (30, 11:10) != (0, 0b11)
-x-------------------------xxxxx  vt1        # ... add 1
-x-------------------------xxxxx  vt2        # ... add 2
-x-------------------------xxxxx  vt3        # ... add 3
-x--------------------xxxxx-----  dq5        # Q register if bit 30 is set, else D
-x-----------------x------------  index2     # index of S subreg in Q: 0-3
-x-----------------xx-----------  index1     # index of H subreg in Q: 0-7
-x-----------------xxx----------  index0     # index of B subreg in Q: 0-15
-x--------------????--xxxxx-----  memvm      # computes multiplier from 15:12
-x----------xxxx----------------  dq16_h_sz # Q register (0-15) if bit 30 is set, else D
-x---------xxxxx----------------  dq16       # Q register if bit 30 is set, else D
?---------------xxxxxx----------  imm6       # shift amount
?---------------xxxxxx----------  imms       # bitfield immediate, checks 31
?---------xxxxxx----------------  immr       # bitfield immediate, checks 31
?--------xx---------------------  imm16sh    # shift for MOVK/... (immediate); checks 31
??--------------------xxxxx-----  mem0       # gets size from 31:30; no offset
??--------------------xxxxx-----  mem9post   # gets size from 31:30; post-index
??---------xxxxxxxxx--xxxxx-----  mem9       # gets size from 31:30
??---------xxxxxxxxx--xxxxx-----  memreg     # register offset, gets size from 31:30
??--------xxxxxxxxxxxxxxxxx-----  mem12      # gets size from 31:30
??---?----------------xxxxx-----  mem7post   # gets size from 31:30 and 26; post-index
??---?----xxxxxxx---------------  mem7off    # gets size from 31:30 and 26
??---?----xxxxxxx-----xxxxx-----  mem7       # gets size from 31:30 and 26
??---?--xxxxxxxxxxxxxxxxxxx-----  memlit     # load literal, gets size from 31:30 and 26
x--------------------------xxxxx  wx0        # W/X register (or WZR/XZR)
x--------------------------xxxxx  wx0sp      # W/X register or WSP/XSP
x---------------------xxxxx-----  wx5        # W/X register (or WZR/XZR)
x---------------------xxxxx-----  wx5sp      # W/X register or WSP/XSP
x----------------xxxxx----------  wx10       # W/X register (or WZR/XZR)
x----------xxxxx----------------  wx16       # W/X register (or WZR/XZR)
