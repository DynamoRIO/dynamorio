/* ******************************************************************************
 * Copyright (c) 2010-2022 Google, Inc.  All rights reserved.
 * ******************************************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/**
 ****************************************************************************
\page page_scatter_gather_emulation Emulating x86 Scatter and Gather Instructions

\tableofcontents

# Background

The x86 gather and scatter instructions were introduced in the AVX2 and AVX512 instruction set extensions. They allow loading or storing a subset of elements in a vector from/to multiple non-contiguous addresses.

AVX2 has only gather instructions, no scatter instructions, whereas AVX512 has both. AVX2 is limited to 256-bit length vectors, whereas AVX512 has 512-bit support. Both support masking of individual memory accesses, using either a special mask register in AVX512 or another vector in AVX2.

Examples of these instructions are (in DR’s IR):
```
vpgatherdd %rax(,%ymm11,4)[4byte] %ymm13 -> %ymm12 %ymm13
```

Above is an AVX2 gather instruction that reads 32-bit doublewords into the 256-bit `ymm12` vector from addresses generated by adding the base address in `rax` to the corresponding index elements in `ymm11`, conditionally based on the masks in `ymm13`. The mask is set to zero on completion, unless the instruction causes an exception.

```
vpscatterdd {%k1} %xmm10 -> %rax(,%xmm11,4)[4byte] %k1
```

Above is an AVX512 scatter instruction that writes 32-bit doublewords from the 128-bit `xmm10` vector to addresses generated by adding the base address in `rax` to the corresponding index element in `xmm11`, conditionally based on the mask reg `k1`. The mask register is set to zero on completion, unless the instruction causes an exception.


# Problem Statement

Scatter and gather instructions pose a challenge to DynamoRIO clients that observe memory addresses (like drcachesim, the DR client that collects memory address and control flow traces). They are complex to handle because:

-  A single gather or scatter instruction loads from or stores to multiple addresses
-  Accessed addresses may be non-contiguous
-  Each access is conditional based on some mask

DynamoRIO clients only see the scatter or gather instruction and need to do more work to extract all accessed addresses. This is unlike regular scalar loads or stores, where the accessed address is readily available. The goal of this work is to make it easier for DR clients to observe these addresses. We achieve this by expanding the scatter and gather instructions into a functionally equivalent sequence of scalar stores and loads. This way, DR clients will see regular store and load instructions which they can instrument as usual.

Original issue: [DynamoRIO/dynamorio#2985](https://github.com/DynamoRIO/dynamorio/issues/2985).

# Design

This required the addition of new support in various DynamoRIO components, like drreg, drx, drmgr and core DR. Multiple contributors worked on designing and implementing the required changes.


## Scatter/gather Instruction Expansion

Owner: [Hendrik Greving](https://github.com/hgreving2304)

As described above, we can simplify work for DR clients by replacing the scatter and gather instructions with a functionally equivalent sequence of scalar stores and loads. The expanded sequence is the unrolled version of the following loop:
```
num_accesses = vector_size / element_size
for i = 0, 1, ..., (num_accesses-1), do
  extract mask for the ith access from mask reg or mask vector
  if mask is set, then
    extract ith element of index vector
    compute address = base + ith index element
    if instr_is_gather, then
      load data from address into a scalar reg
      insert scalar data into destination vector
    else // instr_is_scatter
      Extract scalar data from source vector to scalar reg
      Store data from scalar reg to address
    done
    clear ith mask in mask reg or mask vector
  done
done
```

Due to the x86 ISA, the extraction/insertion of the scalar value from/to the vector may involve multiple steps, e.g. to extract a 32-bit scalar value from a 512-bit `zmm` reg, we first need to extract a 128-bit `xmm` from it.

drmgr in DR provides multiple phases of instrumentation. This expansion is done in the first phase known as app2app. As the name suggests, this phase is intended to transform app instructions to equivalent instructions. For simplicity, we also separate out the scatter or gather instructions from its basic block and create a separate fragment with only the expanded sequence. The logic for expanding scatter and gather instructions is implemented in the drx extension library as [`drx_expand_scatter_gather`](https://github.com/DynamoRIO/dynamorio/blob/eb5d5af8e3444912c9f3f70e5ebf7969252ee4d6/ext/drx/drx.h#L538), and can be used by any client that needs it, including drcachesim. This support was added by [commit](https://github.com/DynamoRIO/dynamorio/commit/4359ef134e47942004c09db04b54593579763186).

As an example, the following are the expansions of some instructions.

Expansion for `vpgatherdd`: https://gist.github.com/abhinav92003/637c07bac785428550f05c18319f80c2

Expansion for `vpscatterdd`: https://gist.github.com/abhinav92003/4a78ec4ad1621cbf6ca905a6774cb389

We also need to make sure that if some load or store faults, we restore the application state properly. While the spilled registers obtained from drreg are restored by the drreg state restoration logic, drx still needs to restore the scratch mask registers that are spilled manually to a GPR and ensure that the bit for the faulting access is cleared too. In case a fault or some other state restore event like DR detach happens, we walk the expanded sequence using a state machine till we reach the fault pc, keeping track of the state that needs to be restored ([commit](https://github.com/DynamoRIO/dynamorio/commit/de511a72197e9b04a9732f33622fe7bc7fd12623), [commit](https://github.com/DynamoRIO/dynamorio/commit/e54913b4845794b96e8682ba6a214d54e10741a0)).


## Drreg Support For Multi-phase Reservations

Owner: [Abhinav Sharma](https://github.com/abhinav92003)

Upstream issue: [DynamoRIO/dynamorio#3823](https://github.com/DynamoRIO/dynamorio/issues/3823)

Drreg is DynamoRIO’s register reservation framework. It allows users to reserve a reg to use as scratch. Internally, drreg automatically performs the following functions so that the user does not need to. Drreg
- keeps all required book-keeping like the spill slot to spilled register mapping
- restores spilled registers to their application value before they are read by an application instruction; also, it re-spills the spilled registers if they are written by an application instruction.
- performs application state restoration on state restore events like encountering an application fault, and DR detach.

While expanding a scatter or gather instruction in the app2app phase, we need a scratch register to hold the scalar values and masks. In later phases (like the insertion or the instru2instru phase), drcachesim and other DR clients may also use drreg to get scratch registers for their instrumentation.

Drreg initially supported only single phase use and did not keep any state between phases. To support multi-phase use of drreg, we need to solve the following:
- avoid spill slot conflict across multiple phases: multi-phase use can potentially lead to spill slot conflicts if the same slot is selected in multiple phases. This may clobber the spilled application value and cause the application to crash or otherwise fail.
- allow aflags spill to any slot: drreg hardcodes the aflags spill slot as the zero-th slot, to simplify some logic. To support the ability to spill aflags in multiple phases, drreg should be able to use any spill slot for aflags.
- application state restore logic: on a state restore event, we should be able to figure out which slot contains each spilled register's app value. This is complicated by the fact that registers may be spilled by instrumentation added by multiple phases, and the spill regions may overlap which causes the spilled application value to be moved between spill slots.

We explored the following ideas to avoid spill slot conflicts in drreg:

#### Disjoint slot spaces or arenas
We can ask drreg to create slot spaces or arenas at init time, which are assigned disjoint spill slots. When reserving a register, the user passes in a “space/arena Id '' to instruct drreg to pick free slots only from that arena. This requires keeping some global drreg state. This also requires the user to guess the best configuration for assigning slots to the arenas, and passing the correct arena Id before each reservation. It may artifically make some spill slots unavailable for use, thereby reducing efficiency.


#### Assign phase Id to slots
Instead of creating slot spaces at init time with a best-guess assignment of slots, we can instead assign a phase Id to slots when they are requested in that phase. We then avoid using slots that are already assigned a phase Id, when we are not in that phase where the slot was used before. This also requires keeping some global drreg state. This does not help in avoiding spill slot conflicts between multiple clients in the same phase.


#### Preferred: Scan fragment to determine eligible slots
When picking a spill slot, we can determine whether using it will cause a slot conflict by scanning for its uses in the current fragment after the current instruction. We pick only that spill slot which does not have any later uses in the current fragment. This does not require any init time guesses or keeping any global drreg state. It does not impose any additional responsibilities on the users, and it also works for multiple clients in the same phase. This was implemented to pick spill slots for GPRs ([commit](https://github.com/DynamoRIO/dynamorio/commit/238bb25de02d4741f52ec368e2118244329d76f0)) and aflags too ([commit](https://github.com/DynamoRIO/dynamorio/commit/a3d0419e4d05113ca8c665f4ef0edb970e3bcf58)).


### State Restoration For Drreg

Owner: [Abhinav Sharma](https://github.com/abhinav92003)

Upstream issue: [DynamoRIO/dynamorio#3823](https://github.com/DynamoRIO/dynamorio/issues/3823), [DynamoRIO/dynamorio#3801](https://github.com/DynamoRIO/dynamorio/issues/3801)

On a state restore event, drreg should be able to restore all spilled registers to their application values.

Unfortunately, when a state restore event happens, we only have the encoded fragment, and none of the drreg state, like the reg to spill slot mappings. We need to reconstruct this state based on the faulting pc and the encoded fragment.


It is complex to determine which registers need to be restored and from which spill slot. This is because drreg automatically adds spill and restore instructions to handle various complex cases like automatic re-spilling of reserved registers after their application write instruction, and automatic restore of reserved registers before their application read instruction. Drreg also uses various optimisations like lazy restores for application value in case the register is reserved again. This is even more complex for aflags, for which spill and restore are a two-step process (spilling aflags involves reading aflags into a register using `lahf` and then writing that register to a spill slot; restoring aflags involves reading aflags from its spill slot to a register, and then writing aflags from that register using `sahf`). In some cases, aflags are even kept in a register as an optimisation.

Additionally, in multi-phase use, a register may be spilled by multiple phases, with a separate spill slot for each phase. The application value for the register may reside in one or more spill slots, and may also move between spill slots based on how the spill regions from different phases overlap. See various tricky scenarios in [drreg-test.c](https://github.com/DynamoRIO/dynamorio/blob/f1d496b451eaa6e9aaff7125617030164c6cfdff/suite/tests/client-interface/drreg-test.c#L637).

We explored two ways to adapt drreg’s state restoration logic to multi-phase use. This also fixed some known existing issues with drreg: [Dynamorio/dynamorio#4933](https://github.com/DynamoRIO/dynamorio/issues/4933), [DynamoRIO/dynamorio#4939](https://github.com/DynamoRIO/dynamorio/issues/4939).

#### Track app values as they are moved between slots and regs
At a state restoration event, we walk the faulting fragment from beginning to the faulting instruction, and we keep track of where the native value of each register is present. At any point, it may be present in the register itself, a spill slot, or both. We track `gpr_is_native` to denote whether a register contains its native app value or not; and `spill_slot_to_reg`, to denote which register’s app value a spill slot contains.

- When a register is written by an application instruction, we invalidate all `spill_slot_to_reg` entries that are mapped to that register, and also set `gpr_is_native` for that register.
- When a register is written by a non-drreg meta instruction, we clear `gpr_is_native` for that reg.
- When a register is loaded by drreg from the slot it was spilled to, we set `gpr_is_native`.
- When a register is spilled to some spill slot, we set `spill_slot_to_reg` for that spill slot to that reg.

This strategy allows us to robustly keep track of the various corner cases that can arise in drreg, like spill regions from different phases overlapping (nesting or just overlapping), and the other known issues linked above. This was implemented by this [commit](https://github.com/DynamoRIO/dynamorio/commit/f62441bc2a0ced41263e2229deb3691433d6abb9).

The drawback of this approach is that it needs to be aware of other methods of spilling and restoring registers outside drreg ([dropped PR](https://github.com/DynamoRIO/dynamorio/pull/4987)). DynamoRIO uses various such methods internally (spilling to stack, slots not managed by drreg), and also the client may use their own unique methods. So, some non-drreg meta instructions may actually restore an application value to a register, but this approach will not be able to recognize that. This may cause it to lose track of some register’s application value. We dropped this approach on encountering [DynamoRIO/dynamorio#4963](https://github.com/DynamoRIO/dynamorio/issues/4963).

#### Preferred: Pairing restores with spills (instead of the other way)

The key observation behind this approach is that it is easier to find the matching spill for a given restore, than to find the matching restore for a given spill. This is because there may be other restores besides the final restore, e.g. restores for app read, user prompted restores, etc. This makes it hard to find exactly where the spill region for a register/aflags ends.  Additional complexities include the fact that aflags re-spills may not use the same slot, which makes differentiating spills from multiple phases difficult.

Each restore must have a matching spill. Based on this observation, we scan the faulting fragment from end to beginning, matching register restores to their spills. When we reach the faulting instruction, any restore for which we did not see the matching spill yet must be performed by the drreg state restoration. This was implemented by ([commit](https://github.com/DynamoRIO/dynamorio/commit/be78c124eb787601182e3c73f4be8bb859c50ef8)).

This algorithm does not need to be aware of non-drreg methods of spilling/restoring registers.

## Simplifying Instrumentation For Emulated Instructions
Owner: [Derek Bruening](https://github.com/derekbruening)

Upstream Issue: [DynamoRIO/dynamorio#4865](https://github.com/DynamoRIO/dynamorio/issues/4865)

Emulated sequences like the expanded scatter and gather sequence described above pose another challenge for clients that need to observe instructions and memory references both. For observing instructions, these clients should see the original application instruction (that is, the scatter or gather instruction), whereas for observing memory references, they should see the emulated sequence (that is, all the individual scalar stores or loads). DynamoRIO should absorb this complexity and provides the required events to the client.

We implemented `drmgr_orig_app_instr_for_fetch`, `drmgr_orig_app_instr_for_operands` and `drmgr_in_emulation_region` APIs ([commit](https://github.com/DynamoRIO/dynamorio/commit/eb5d5af8e3444912c9f3f70e5ebf7969252ee4d6), [commit](https://github.com/DynamoRIO/dynamorio/commit/6d84fea04a036038db5a3af2e979e77d2cd356c0)) that return the appropriate instruction to the client to be used for either instruction instrumentation or memory reference instrumentation. These were subsequently used in drcachesim as well ([commit](https://github.com/DynamoRIO/dynamorio/commit/8b9be0fd04e40deb41d993e8d846b69160fb4f04)).


## Support For Vector Reservation

Owner: [Abhinav Sharma](https://github.com/abhinav92003)

The scatter and gather expansions requires a scratch `xmm` register, for which we need
the capability to spill and restore vector registers. Following are the design
choices:

- Extend drreg to support reservation for vector registers.
  [DynamoRIO/dynamorio#3844](https://github.com/DynamoRIO/dynamorio/issues/3844)
  aims to add this support.

- Use custom spill and restore logic in drx. We can do this by reserving memory in
TLS to use as spill slot.


Some observations about this use-case for vector reservation:
- We need to spill only one vector register, so we do not need sophisticated spill slot management logic.
- The spilled vector register will not need to be restored for app reads, or re-spilled after app writes. Note that we will not encounter any application instructions that use the spilled vector register, because it needs to be spilled only for the duration of the expanded scatter or gather sequence.

Extending drreg to support vector spilling is a complex task. Given the above observations, the current use case does not justify the effort. Therefore, we choose to implement custom spill logic in drx ([commit](https://github.com/DynamoRIO/dynamorio/commit/88cba2817fef7a4d4ba3e8c2375784ea4165c133), [commit](https://github.com/DynamoRIO/dynamorio/commit/84bf9288a12e8e38abab04d4d8273cc3226fa13c)).


## Using The Expansion In DR Clients

Owner: [Abhinav Sharma](https://github.com/abhinav92003)

Clients that need to observe each memory reference must use the `drx_expand_scatter_gather` API. This was added in the app2app phase of drcachesim and other DynamoRIO clients ([commit](https://github.com/DynamoRIO/dynamorio/commit/cf9d6a95262015581a5184e75ce599cc66ac4df4)). This also required fixing some issues (crashes and correctness problems) that surfaced when all pieces were integrated ([commit](https://github.com/DynamoRIO/dynamorio/commit/ced6e253b2e6bb7f1402398798d4bd8a988dacd0), [commit](https://github.com/DynamoRIO/dynamorio/commit/e9f05212a7c1f2ff969cabdacd92914865345303)).

# Testing On Large Apps

Owner: [Abhinav Sharma](https://github.com/abhinav92003)

drcachesim was successfully used to trace an application with scatter and gather instructions. The resulting trace was observed to have millions of such instructions. We also verified correctness by comparing application output with and without tracing.


 ***************************************************************************
 */

