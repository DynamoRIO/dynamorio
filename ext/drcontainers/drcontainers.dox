/* **********************************************************
 * Copyright (c) 2011 Google, Inc.  All rights reserved.
 * Copyright (c) 2010 VMware, Inc.  All rights reserved.
 * **********************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of VMware, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/**
***************************************************************************
***************************************************************************
\page page_drcontainers Container Data Structures

The \p drcontainers DynamoRIO Extension provides container data structures
that use the DR API for memory allocation and synchronization.

 - \ref sec_drcontainers_setup
 - \ref sec_drcontainers_hashtable
 - \ref sec_drcontainers_vector
 - \ref sec_drcontainers_table

\section sec_drcontainers_setup Setup

To use \p drcontainers with your client simply include this line in your client's
\p CMakeLists.txt file:

\code use_DynamoRIO_extension(clientname drcontainers) \endcode

That will automatically set up the include path and library dependence.

\section sec_drcontainers_hashtable Hashtable

The hashtable supports integer, string, and custom hash keys, and has
synchronization and memory allocation and deallocation parametrized for
flexible usage.  See hashtable_init_ex() and related functions.

\section sec_drcontainers_vector DrVector

The \p drvector DynamoRIO Extension provides a simple resizable array (a vector).

\subsection sec_drvector_init Initialization

Initialize a vector with drvector_init():
\code
drvector_t vec;
drvector_init(&vec, 10, true, free_callback);
\endcode

The \p initial_capacity can be 0, in which case the internal array is lazily allocated
upon the first insertion (using an internal default initial size).

\subsection sec_drvector_ops Operations

Entries can be added to the end of the vector using drvector_append():
\code
drvector_append(&vec, data);
\endcode

Entries can be retrieved or set by index:
\code
void *data = drvector_get_entry(&vec, 5);
drvector_set_entry(&vec, 3, new_data);
\endcode

drvector_get_entry() returns \p NULL if the index is out of bounds.

For an unsynchronized vector, the caller is free to directly access the \p array
field of the \p drvector_t structure for better performance.

drvector_set_entry() will automatically resize the vector if the index is beyond
the current capacity. It also updates the number of entries to be \p idx + 1 if the
index is greater than or equal to the current number of entries. Note that entries in
between the last set index and the current index are left uninitialized, hence clearing
or deleting a vector that has a \p free_callback set can be problematic, as the
\p free_callback function will be called on uninitialized entries. It's the user
responsibility to set all entries.

\subsection sec_drcontainers_vector_synch Synchronization

The vector can be initialized to automatically synchronize each operation by
passing \p true for the \p synch parameter to drvector_init().

Even when \p synch is \p false, the vector's lock is initialized and can be
manually acquired and released:
\code
drvector_lock(&vec);
/* perform multiple operations or access vec->array directly */
drvector_unlock(&vec);
\endcode

\subsection sec_drcontainers_vector_mem Memory Management

A callback for freeing each data item can be provided to drvector_init().
This callback is called for each entry when drvector_delete() or drvector_clear()
is called.

The #drvector_t.zero_alloc field can be set to \p true to ensure that any new memory
allocated during resizing is zeroed. When \p zero_alloc is \p true, drvector_clear()
also zeros the entire array after calling the free callback.

To completely free the vector's storage:
\code
drvector_delete(&vec);
\endcode

To clear the vector without freeing its internal storage:
\code
drvector_clear(&vec);
\endcode

\subsection sec_drvector_example Example

\code
void free_data(void *ptr) {
    dr_global_free(ptr, sizeof(int));
}

drvector_t vec;
drvector_init(&vec, 0, false, free_data);
vec.zero_alloc = true;

int *data = dr_global_alloc(sizeof(int));
*data = 42;
drvector_append(&vec, data);

/* Accessing by index */
int *val = (int *)drvector_get_entry(&vec, 0);

/* Direct access (unsynchronized) */
if (vec.entries > 0)
    val = (int *)vec.array[0];

drvector_delete(&vec);
\endcode

\section sec_drcontainers_table DrTable

The DrTable is a resizable array that does not relocate data,
enabling a user to use pointers to access array entries directly.

*/
