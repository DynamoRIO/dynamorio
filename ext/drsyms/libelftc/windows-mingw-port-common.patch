diff --git a/common/_elftc.h b/common/_elftc.h
index 5be8145b..898bee40 100644
--- a/common/_elftc.h
+++ b/common/_elftc.h
@@ -325,2 +325,6 @@ struct name {							\
 
+#ifndef ELFTC_VCSID
+#define ELFTC_VCSID(ID) /* nothing */
+#endif
+
 #endif	/* ELFTC_VCSID */
@@ -372,2 +376,10 @@ extern const char *__progname;
 
+#if defined _WIN32 && ! defined __CYGWIN__
+#include "windows-mingw/endian.h"
+
+#define	ELFTC_BYTE_ORDER			__BYTE_ORDER
+#define	ELFTC_BYTE_ORDER_LITTLE_ENDIAN		__LITTLE_ENDIAN
+#define	ELFTC_BYTE_ORDER_BIG_ENDIAN		__BIG_ENDIAN
+#endif
+
 #if defined(__APPLE__)
@@ -449,3 +461,7 @@ extern const char *__progname;
 
+#if !(defined _WIN32 && ! defined __CYGWIN__)
 #include <sys/param.h>
+#else
+#include "windows-mingw/sys_param.h"
+#endif
 #include <sys/endian.h>
@@ -468,3 +484,7 @@ extern const char *__progname;
 
+#if !(defined _WIN32 && ! defined __CYGWIN__)
 #include <sys/param.h>
+#else
+#include "windows-mingw/sys_param.h"
+#endif
 #include <sys/endian.h>
diff --git a/common/windows-mingw/_ansi.h b/common/windows-mingw/_ansi.h
new file mode 100644
index 00000000..3a8d0838
--- /dev/null
+++ b/common/windows-mingw/_ansi.h
@@ -0,0 +1,73 @@
+/* Provide support for both ANSI and non-ANSI environments.  */
+
+/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
+   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
+   files aren't affected).  */
+
+#ifndef	_ANSIDECL_H_
+#define	_ANSIDECL_H_
+
+#include "newlib.h"
+//#include <sys/config.h>
+
+/*  ISO C++.  */
+
+#ifdef __cplusplus
+#if !(defined(_BEGIN_STD_C) && defined(_END_STD_C))
+#ifdef _HAVE_STD_CXX
+#define _BEGIN_STD_C namespace std { extern "C" {
+#define _END_STD_C  } }
+#else
+#define _BEGIN_STD_C extern "C" {
+#define _END_STD_C  }
+#endif
+#define _NOTHROW __attribute__ ((__nothrow__))
+#endif
+#else
+#define _BEGIN_STD_C
+#define _END_STD_C
+#define _NOTHROW
+#endif
+
+#ifndef _LONG_DOUBLE
+#define _LONG_DOUBLE long double
+#endif
+
+/* Support gcc's __attribute__ facility.  */
+
+#ifdef __GNUC__
+#define _ATTRIBUTE(attrs) __attribute__ (attrs)
+#else
+#define _ATTRIBUTE(attrs)
+#endif
+
+/*  The traditional meaning of 'extern inline' for GCC is not
+  to emit the function body unless the address is explicitly
+  taken.  However this behaviour is changing to match the C99
+  standard, which uses 'extern inline' to indicate that the
+  function body *must* be emitted.  Likewise, a function declared
+  without either 'extern' or 'static' defaults to extern linkage
+  (C99 6.2.2p5), and the compiler may choose whether to use the
+  inline version or call the extern linkage version (6.7.4p6).
+  If we are using GCC, but do not have the new behaviour, we need
+  to use extern inline; if we are using a new GCC with the
+  C99-compatible behaviour, or a non-GCC compiler (which we will
+  have to hope is C99, since there is no other way to achieve the
+  effect of omitting the function if it isn't referenced) we use
+  'static inline', which c99 defines to mean more-or-less the same
+  as the Gnu C 'extern inline'.  */
+#if defined(__GNUC__) && !defined(__GNUC_STDC_INLINE__)
+/* We're using GCC, but without the new C99-compatible behaviour.  */
+#define _ELIDABLE_INLINE extern __inline__ _ATTRIBUTE ((__always_inline__))
+#else
+/* We're using GCC in C99 mode, or an unknown compiler which
+  we just have to hope obeys the C99 semantics of inline.  */
+#define _ELIDABLE_INLINE static __inline__
+#endif
+
+
+#define _NOINLINE		__attribute__ ((__noinline__))
+#define _NOINLINE_STATIC	_NOINLINE static
+
+
+#endif /* _ANSIDECL_H_ */
diff --git a/common/windows-mingw/_newlib_version.h b/common/windows-mingw/_newlib_version.h
new file mode 100644
index 00000000..f79befff
--- /dev/null
+++ b/common/windows-mingw/_newlib_version.h
@@ -0,0 +1,12 @@
+/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
+/* Version macros for internal and downstream use. */
+#ifndef _NEWLIB_VERSION_H__
+#define _NEWLIB_VERSION_H__ 1
+
+#define _NEWLIB_VERSION "3.3.0"
+#define __NEWLIB__ 3
+#define __NEWLIB_MINOR__ 3
+#define __NEWLIB_PATCHLEVEL__ 0
+
+#endif /* !_NEWLIB_VERSION_H__ */
+
diff --git a/common/windows-mingw/ar.h b/common/windows-mingw/ar.h
new file mode 100644
index 00000000..38d6ff8b
--- /dev/null
+++ b/common/windows-mingw/ar.h
@@ -0,0 +1,65 @@
+/*	$NetBSD: ar.h,v 1.4 1994/10/26 00:55:43 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Hugh Smith at The University of Guelph.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ar.h	8.2 (Berkeley) 1/21/94
+ */
+
+#ifndef _AR_H_
+#define	_AR_H_
+
+/* Pre-4BSD archives had these magic numbers in them. */
+#define	OARMAG1	0177555
+#define	OARMAG2	0177545
+
+#define	ARMAG		"!<arch>\n"	/* ar "magic number" */
+#define	SARMAG		8		/* strlen(ARMAG); */
+
+#define	AR_EFMT1	"#1/"		/* extended format #1 */
+
+struct ar_hdr {
+    char ar_name[16];		/* name */
+    char ar_date[12];		/* modification time */
+    char ar_uid[6];			/* user id */
+    char ar_gid[6];			/* group id */
+    char ar_mode[8];		/* octal file permissions */
+    char ar_size[10];		/* size in bytes */
+#define	ARFMAG	"`\n"
+    char ar_fmag[2];		/* consistency check */
+};
+
+#endif /* !_AR_H_ */
\ No newline at end of file
diff --git a/common/windows-mingw/bits_byteswap.h b/common/windows-mingw/bits_byteswap.h
new file mode 100644
index 00000000..cb7835db
--- /dev/null
+++ b/common/windows-mingw/bits_byteswap.h
@@ -0,0 +1,37 @@
+/* bits/byteswap.h
+
+This file is part of Cygwin.
+
+This software is a copyrighted work licensed under the terms of the
+Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
+details. */
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static __inline unsigned short
+__bswap_16 (unsigned short __x)
+{
+    return (__x >> 8) | (__x << 8);
+}
+
+static __inline unsigned int
+__bswap_32 (unsigned int __x)
+{
+    return (__bswap_16 (__x & 0xffff) << 16) | (__bswap_16 (__x >> 16));
+}
+
+static __inline unsigned long long
+__bswap_64 (unsigned long long __x)
+{
+    return (((unsigned long long) __bswap_32 (__x & 0xffffffffull)) << 32) | (__bswap_32 (__x >> 32));
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _BITS_BYTESWAP_H */
diff --git a/common/windows-mingw/endian.h b/common/windows-mingw/endian.h
new file mode 100644
index 00000000..5042d72e
--- /dev/null
+++ b/common/windows-mingw/endian.h
@@ -0,0 +1,191 @@
+/* endian.h
+
+This file is part of Cygwin.
+
+This software is a copyrighted work licensed under the terms of the
+Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
+details. */
+
+#ifndef _ENDIAN_H_
+#define _ENDIAN_H_
+
+#include <stdint.h>
+//#include <sys/config.h>
+#include "machine_endian.h"
+
+/*#ifdef  __USE_BSD*/
+# ifndef LITTLE_ENDIAN
+#  define LITTLE_ENDIAN __LITTLE_ENDIAN
+# endif
+# ifndef BIG_ENDIAN
+#  define BIG_ENDIAN    __BIG_ENDIAN
+# endif
+# ifndef PDP_ENDIAN
+#  define PDP_ENDIAN    __PDP_ENDIAN
+# endif
+# ifndef BYTE_ORDER
+#  define BYTE_ORDER    __BYTE_ORDER
+# endif
+/*#endif*/
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) LO, HI
+#elif __BYTE_ORDER == __BIG_ENDIAN
+# define __LONG_LONG_PAIR(HI, LO) HI, LO
+#endif
+
+//#if __BSD_VISIBLE
+
+#include "bits_byteswap.h"
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+
+#define htobe16(x) __bswap_16(x)
+#define htobe32(x) __bswap_32(x)
+#define htobe64(x) __bswap_64(x)
+
+#define be16toh(x) __bswap_16(x)
+#define be32toh(x) __bswap_32(x)
+#define be64toh(x) __bswap_64(x)
+
+#define htole16(x) (x)
+#define htole32(x) (x)
+#define htole64(x) (x)
+
+#define le16toh(x) (x)
+#define le32toh(x) (x)
+#define le64toh(x) (x)
+
+#endif /*__BYTE_ORDER == __LITTLE_ENDIAN*/
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+
+#define htobe16(x) (x)
+#define htobe32(x) (x)
+#define htobe64(x) (x)
+
+#define be16toh(x) (x)
+#define be32toh(x) (x)
+#define be64toh(x) (x)
+
+#define htole16(x) __bswap_16(x)
+#define htole32(x) __bswap_32(x)
+#define htole64(x) __bswap_64(x)
+
+#define le16toh(x) __bswap_16(x)
+#define le32toh(x) __bswap_32(x)
+#define le64toh(x) __bswap_64(x)
+
+#endif /*__BYTE_ORDER == __BIG_ENDIAN*/
+
+//#endif /*__BSD_VISIBLE*/
+
+/* Alignment-agnostic encode/decode bytestream to/from little/big endian. */
+
+static __inline uint16_t
+be16dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return ((p[0] << 8) | p[1]);
+}
+
+static __inline uint32_t
+be32dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return (((unsigned)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]);
+}
+
+static __inline uint64_t
+be64dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return (((uint64_t)be32dec(p) << 32) | be32dec(p + 4));
+}
+
+static __inline uint16_t
+le16dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return ((p[1] << 8) | p[0]);
+}
+
+static __inline uint32_t
+le32dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return (((unsigned)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);
+}
+
+static __inline uint64_t
+le64dec(const void *pp)
+{
+    uint8_t const *p = (uint8_t const *)pp;
+
+    return (((uint64_t)le32dec(p + 4) << 32) | le32dec(p));
+}
+
+static __inline void
+be16enc(void *pp, uint16_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    p[0] = (u >> 8) & 0xff;
+    p[1] = u & 0xff;
+}
+
+static __inline void
+be32enc(void *pp, uint32_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    p[0] = (u >> 24) & 0xff;
+    p[1] = (u >> 16) & 0xff;
+    p[2] = (u >> 8) & 0xff;
+    p[3] = u & 0xff;
+}
+
+static __inline void
+be64enc(void *pp, uint64_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    be32enc(p, (uint32_t)(u >> 32));
+    be32enc(p + 4, (uint32_t)(u & 0xffffffffU));
+}
+
+static __inline void
+le16enc(void *pp, uint16_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    p[0] = u & 0xff;
+    p[1] = (u >> 8) & 0xff;
+}
+
+static __inline void
+le32enc(void *pp, uint32_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    p[0] = u & 0xff;
+    p[1] = (u >> 8) & 0xff;
+    p[2] = (u >> 16) & 0xff;
+    p[3] = (u >> 24) & 0xff;
+}
+
+static __inline void
+le64enc(void *pp, uint64_t u)
+{
+    uint8_t *p = (uint8_t *)pp;
+
+    le32enc(p, (uint32_t)(u & 0xffffffffU));
+    le32enc(p + 4, (uint32_t)(u >> 32));
+}
+
+#endif /*_ENDIAN_H_*/
\ No newline at end of file
diff --git a/common/windows-mingw/machine_endian.h b/common/windows-mingw/machine_endian.h
new file mode 100644
index 00000000..1b1d8cd4
--- /dev/null
+++ b/common/windows-mingw/machine_endian.h
@@ -0,0 +1,114 @@
+#ifndef __MACHINE_ENDIAN_H__
+#define	__MACHINE_ENDIAN_H__
+
+#include <sys/cdefs.h>
+//#include <sys/_types.h>
+#include "_ansi.h"
+
+#ifndef _BITS_ENDIAN_H_
+#define _BITS_ENDIAN_H_
+
+#ifndef __BIG_ENDIAN
+# define __BIG_ENDIAN 4321
+#endif
+#ifndef __LITTLE_ENDIAN
+# define __LITTLE_ENDIAN 1234
+#endif
+
+#ifndef __BYTE_ORDER
+# define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
+
+#endif /* _BITS_ENDIAN_H_ */
+
+#define _LITTLE_ENDIAN __LITTLE_ENDIAN
+#define _BIG_ENDIAN    __BIG_ENDIAN
+#define _PDP_ENDIAN    __PDP_ENDIAN
+#define _BYTE_ORDER    __BYTE_ORDER
+
+#define __machine_host_to_from_network_defined
+
+_ELIDABLE_INLINE uint32_t __ntohl(uint32_t);
+_ELIDABLE_INLINE uint16_t __ntohs(uint16_t);
+
+_ELIDABLE_INLINE uint32_t
+__ntohl(uint32_t _x)
+{
+__asm__("bswap %0" : "=r" (_x) : "0" (_x));
+return _x;
+}
+
+_ELIDABLE_INLINE uint16_t
+__ntohs(uint16_t _x)
+{
+__asm__("xchgb %b0,%h0"		/* swap bytes		*/
+: "=Q" (_x)
+:  "0" (_x));
+return _x;
+}
+
+#define __htonl(_x) __ntohl(_x)
+#define __htons(_x) __ntohs(_x)
+
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define	_QUAD_HIGHWORD	1
+#define	_QUAD_LOWWORD	0
+#else
+#define	_QUAD_HIGHWORD	0
+#define	_QUAD_LOWWORD	1
+#endif
+
+#if __BSD_VISIBLE
+#define	LITTLE_ENDIAN	_LITTLE_ENDIAN
+#define	BIG_ENDIAN	_BIG_ENDIAN
+#define	PDP_ENDIAN	_PDP_ENDIAN
+#define	BYTE_ORDER	_BYTE_ORDER
+#endif
+
+#ifdef __GNUC__
+#define	__bswap16(_x)	__builtin_bswap16(_x)
+#define	__bswap32(_x)	__builtin_bswap32(_x)
+#define	__bswap64(_x)	__builtin_bswap64(_x)
+#else /* __GNUC__ */
+static __inline uint16_t
+__bswap16(uint16_t _x)
+{
+
+    return ((uint16_t)((_x >> 8) | ((_x << 8) & 0xff00)));
+}
+
+static __inline uint32_t
+__bswap32(uint32_t _x)
+{
+
+    return ((uint32_t)((_x >> 24) | ((_x >> 8) & 0xff00) |
+                         ((_x << 8) & 0xff0000) | ((_x << 24) & 0xff000000)));
+}
+
+static __inline __uint64_t
+__bswap64(__uint64_t _x)
+{
+
+    return ((__uint64_t)((_x >> 56) | ((_x >> 40) & 0xff00) |
+                         ((_x >> 24) & 0xff0000) | ((_x >> 8) & 0xff000000) |
+                         ((_x << 8) & ((__uint64_t)0xff << 32)) |
+                         ((_x << 24) & ((__uint64_t)0xff << 40)) |
+                         ((_x << 40) & ((__uint64_t)0xff << 48)) | ((_x << 56))));
+}
+#endif /* !__GNUC__ */
+
+#ifndef __machine_host_to_from_network_defined
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define	__htonl(_x)	__bswap32(_x)
+#define	__htons(_x)	__bswap16(_x)
+#define	__ntohl(_x)	__bswap32(_x)
+#define	__ntohs(_x)	__bswap16(_x)
+#else
+#define	__htonl(_x)	((uint32_t)(_x))
+#define	__htons(_x)	((uint16_t)(_x))
+#define	__ntohl(_x)	((uint32_t)(_x))
+#define	__ntohs(_x)	((uint16_t)(_x))
+#endif
+#endif /* __machine_host_to_from_network_defined */
+
+#endif /* __MACHINE_ENDIAN_H__ */
diff --git a/common/windows-mingw/newlib.h b/common/windows-mingw/newlib.h
new file mode 100644
index 00000000..ccdfc5dd
--- /dev/null
+++ b/common/windows-mingw/newlib.h
@@ -0,0 +1,209 @@
+/* newlib.h.  Generated from newlib.hin by configure.  */
+/* newlib.hin.  Manually edited from the output of autoheader to
+   remove all PACKAGE_ macros which will collide with any user
+   package using newlib header files and having its own package name,
+   version, etc...  */
+#ifndef __NEWLIB_H__
+
+#define __NEWLIB_H__ 1
+
+/* EL/IX level */
+/* #undef _ELIX_LEVEL */
+
+/* Newlib version */
+#include "_newlib_version.h"
+
+/* C99 formats support (such as %a, %zu, ...) in IO functions like
+ * printf/scanf enabled */
+#define _WANT_IO_C99_FORMATS 1
+
+/* long long type support in IO functions like printf/scanf enabled */
+#define _WANT_IO_LONG_LONG 1
+
+/* Register application finalization function using atexit. */
+/* #undef _WANT_REGISTER_FINI */
+
+/* long double type support in IO functions like printf/scanf enabled */
+#define _WANT_IO_LONG_DOUBLE 1
+
+/* Positional argument support in printf functions enabled.  */
+#define _WANT_IO_POS_ARGS 1
+
+/* Optional reentrant struct support.  Used mostly on platforms with
+   very restricted storage.  */
+/* #undef _WANT_REENT_SMALL */
+
+/* Verify _REENT_CHECK macros allocate memory successfully. */
+#define _REENT_CHECK_VERIFY 1
+
+/* Multibyte supported */
+#define _MB_CAPABLE 1
+
+/* MB_LEN_MAX */
+#define _MB_LEN_MAX 8
+
+/* ICONV enabled */
+/* #undef _ICONV_ENABLED */
+
+/* Enable ICONV external CCS files loading capabilities */
+/* #undef _ICONV_ENABLE_EXTERNAL_CCS */
+
+/* Define if the linker supports .preinit_array/.init_array/.fini_array
+ * sections.  */
+/* #undef HAVE_INITFINI_ARRAY */
+
+/* True if atexit() may dynamically allocate space for cleanup
+   functions.  */
+#define _ATEXIT_DYNAMIC_ALLOC 1
+
+/* True if long double supported.  */
+#define _HAVE_LONG_DOUBLE 1
+
+/* Define if compiler supports -fno-tree-loop-distribute-patterns. */
+#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1
+
+/* True if long double supported and it is equal to double.  */
+/* #undef _LDBL_EQ_DBL */
+
+/* Define if ivo supported in streamio.  */
+#define _FVWRITE_IN_STREAMIO 1
+
+/* Define if fseek functions support seek optimization.  */
+#define _FSEEK_OPTIMIZATION 1
+
+/* Define if wide char orientation is supported.  */
+#define _WIDE_ORIENT 1
+
+/* Define if unbuffered stream file optimization is supported.  */
+#define _UNBUF_STREAM_OPT 1
+
+/* Define if lite version of exit supported.  */
+/* #undef _LITE_EXIT */
+
+/* Define if declare atexit data as global.  */
+/* #undef _REENT_GLOBAL_ATEXIT */
+
+/* Define to move the stdio stream FILE objects out of struct _reent and make
+   them global.  The stdio stream pointers of struct _reent are initialized to
+   point to the global stdio FILE stream objects. */
+/* #undef _WANT_REENT_GLOBAL_STDIO_STREAMS */
+
+/* Define if small footprint nano-formatted-IO implementation used.  */
+/* #undef _NANO_FORMATTED_IO */
+
+/* Define if using retargetable functions for default lock routines.  */
+/* #undef _RETARGETABLE_LOCKING */
+
+/* Define to use type long for time_t.  */
+/* #undef _WANT_USE_LONG_TIME_T */
+
+/*
+ * Iconv encodings enabled ("to" direction)
+ */
+/* #undef _ICONV_TO_ENCODING_BIG5 */
+/* #undef _ICONV_TO_ENCODING_CP775 */
+/* #undef _ICONV_TO_ENCODING_CP850 */
+/* #undef _ICONV_TO_ENCODING_CP852 */
+/* #undef _ICONV_TO_ENCODING_CP855 */
+/* #undef _ICONV_TO_ENCODING_CP866 */
+/* #undef _ICONV_TO_ENCODING_EUC_JP */
+/* #undef _ICONV_TO_ENCODING_EUC_TW */
+/* #undef _ICONV_TO_ENCODING_EUC_KR */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
+/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
+/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
+/* #undef _ICONV_TO_ENCODING_KOI8_R */
+/* #undef _ICONV_TO_ENCODING_KOI8_RU */
+/* #undef _ICONV_TO_ENCODING_KOI8_U */
+/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
+/* #undef _ICONV_TO_ENCODING_UCS_2 */
+/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
+/* #undef _ICONV_TO_ENCODING_UCS_2BE */
+/* #undef _ICONV_TO_ENCODING_UCS_2LE */
+/* #undef _ICONV_TO_ENCODING_UCS_4 */
+/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
+/* #undef _ICONV_TO_ENCODING_UCS_4BE */
+/* #undef _ICONV_TO_ENCODING_UCS_4LE */
+/* #undef _ICONV_TO_ENCODING_US_ASCII */
+/* #undef _ICONV_TO_ENCODING_UTF_16 */
+/* #undef _ICONV_TO_ENCODING_UTF_16BE */
+/* #undef _ICONV_TO_ENCODING_UTF_16LE */
+/* #undef _ICONV_TO_ENCODING_UTF_8 */
+/* #undef _ICONV_TO_ENCODING_WIN_1250 */
+/* #undef _ICONV_TO_ENCODING_WIN_1251 */
+/* #undef _ICONV_TO_ENCODING_WIN_1252 */
+/* #undef _ICONV_TO_ENCODING_WIN_1253 */
+/* #undef _ICONV_TO_ENCODING_WIN_1254 */
+/* #undef _ICONV_TO_ENCODING_WIN_1255 */
+/* #undef _ICONV_TO_ENCODING_WIN_1256 */
+/* #undef _ICONV_TO_ENCODING_WIN_1257 */
+/* #undef _ICONV_TO_ENCODING_WIN_1258 */
+
+/*
+ * Iconv encodings enabled ("from" direction)
+ */
+/* #undef _ICONV_FROM_ENCODING_BIG5 */
+/* #undef _ICONV_FROM_ENCODING_CP775 */
+/* #undef _ICONV_FROM_ENCODING_CP850 */
+/* #undef _ICONV_FROM_ENCODING_CP852 */
+/* #undef _ICONV_FROM_ENCODING_CP855 */
+/* #undef _ICONV_FROM_ENCODING_CP866 */
+/* #undef _ICONV_FROM_ENCODING_EUC_JP */
+/* #undef _ICONV_FROM_ENCODING_EUC_TW */
+/* #undef _ICONV_FROM_ENCODING_EUC_KR */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
+/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
+/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
+/* #undef _ICONV_FROM_ENCODING_KOI8_R */
+/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
+/* #undef _ICONV_FROM_ENCODING_KOI8_U */
+/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
+/* #undef _ICONV_FROM_ENCODING_UCS_2 */
+/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
+/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
+/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
+/* #undef _ICONV_FROM_ENCODING_UCS_4 */
+/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
+/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
+/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
+/* #undef _ICONV_FROM_ENCODING_US_ASCII */
+/* #undef _ICONV_FROM_ENCODING_UTF_16 */
+/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
+/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
+/* #undef _ICONV_FROM_ENCODING_UTF_8 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
+/* #undef _ICONV_FROM_ENCODING_WIN_1258 */
+
+#endif /* !__NEWLIB_H__ */
+
diff --git a/common/windows-mingw/sys_param.h b/common/windows-mingw/sys_param.h
new file mode 100644
index 00000000..63de726e
--- /dev/null
+++ b/common/windows-mingw/sys_param.h
@@ -0,0 +1,68 @@
+/* sys/param.h
+
+   This software is a copyrighted work licensed under the terms of the
+   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
+   details. */
+
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H
+
+#include <sys/types.h>
+/* Linux includes limits.h, but this is not universally done. */
+#include <limits.h>
+
+#define __need_NULL
+#include <stddef.h>
+
+/* Max number of open files.  The Posix version is OPEN_MAX.  */
+/* Number of fds is virtually unlimited in cygwin, but we must provide
+   some reasonable value for Posix conformance */
+#define NOFILE		8192
+
+/* Max number of groups; must keep in sync with NGROUPS_MAX in limits.h */
+#define NGROUPS		NGROUPS_MAX
+
+/* Ticks/second for system calls such as times() */
+/* FIXME: is this the appropriate value? */
+#define HZ		1000
+
+/* Max hostname size that can be dealt with (== Win32 MAX_HOSTNAME_LEN) */
+#define MAXHOSTNAMELEN	128
+
+/* Maximum path length including trailing NUL; the Posix version is PATH_MAX.
+   MAXPATHLEN is the BSD variant. */
+#define MAXPATHLEN      PATH_MAX
+
+/* Maximum number of nested symlinks; the Posix version is SYMLOOP_MAX.
+   MAXSYMLINKS is the BSD variant. */
+#define MAXSYMLINKS	SYMLOOP_MAX
+
+/* This is the number of bytes per block given in the st_blocks stat member.
+   It should be in sync with S_BLKSIZE in sys/stat.h.  S_BLKSIZE is the
+   BSD variant of this constant. */
+#define DEV_BSIZE	1024
+
+#ifndef NBBY
+#define    NBBY 8
+#endif
+
+/* Bit map related macros. */
+#define    setbit(a,i) ((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define    clrbit(a,i) ((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define    isset(a,i)  ((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define    isclr(a,i)  (((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding. */
+#ifndef howmany
+#define    howmany(x, y)   (((x)+((y)-1))/(y))
+#endif
+#define    rounddown(x, y) (((x)/(y))*(y))
+#define    roundup(x, y)   ((((x)+((y)-1))/(y))*(y))  /* to any y */
+#define    roundup2(x, y)  (((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define powerof2(x)    ((((x)-1)&(x))==0)
+
+/* Macros for min/max. */
+#define    MIN(a,b)    (((a)<(b))?(a):(b))
+#define    MAX(a,b)    (((a)>(b))?(a):(b))
+
+#endif
diff --git a/common/windows-mingw/sys_queue.h b/common/windows-mingw/sys_queue.h
new file mode 100644
index 00000000..006a37fd
--- /dev/null
+++ b/common/windows-mingw/sys_queue.h
@@ -0,0 +1,914 @@
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ * $FreeBSD$
+ */
+
+#ifndef _SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+#include <sys/cdefs.h>
+
+/*
+ * This file defines four types of data structures: singly-linked lists,
+ * singly-linked tail queues, lists and tail queues.
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A singly-linked tail queue is headed by a pair of pointers, one to the
+ * head of the list and the other to the tail of the list. The elements are
+ * singly linked for minimum space and pointer manipulation overhead at the
+ * expense of O(n) removal for arbitrary elements. New elements can be added
+ * to the list after an existing element, at the head of the list, or at the
+ * end of the list. Elements being removed from the head of the tail queue
+ * should use the explicit macro for this purpose for optimum efficiency.
+ * A singly-linked tail queue may only be traversed in the forward direction.
+ * Singly-linked tail queues are ideal for applications with large datasets
+ * and few or no removals or for implementing a FIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may be traversed in either direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ *
+ * Below is a summary of implemented functions where:
+ *  +  means the macro is available
+ *  -  means the macro is not available
+ *  s  means the macro is available but is slow (runs in O(n) time)
+ *
+ *				SLIST	LIST	STAILQ	TAILQ
+ * _HEAD			+	+	+	+
+ * _CLASS_HEAD			+	+	+	+
+ * _HEAD_INITIALIZER		+	+	+	+
+ * _ENTRY			+	+	+	+
+ * _CLASS_ENTRY			+	+	+	+
+ * _INIT			+	+	+	+
+ * _EMPTY			+	+	+	+
+ * _FIRST			+	+	+	+
+ * _NEXT			+	+	+	+
+ * _PREV			-	+	-	+
+ * _LAST			-	-	+	+
+ * _LAST_FAST			-	-	-	+
+ * _FOREACH			+	+	+	+
+ * _FOREACH_FROM		+	+	+	+
+ * _FOREACH_SAFE		+	+	+	+
+ * _FOREACH_FROM_SAFE		+	+	+	+
+ * _FOREACH_REVERSE		-	-	-	+
+ * _FOREACH_REVERSE_FROM	-	-	-	+
+ * _FOREACH_REVERSE_SAFE	-	-	-	+
+ * _FOREACH_REVERSE_FROM_SAFE	-	-	-	+
+ * _INSERT_HEAD			+	+	+	+
+ * _INSERT_BEFORE		-	+	-	+
+ * _INSERT_AFTER		+	+	+	+
+ * _INSERT_TAIL			-	-	+	+
+ * _CONCAT			s	s	+	+
+ * _REMOVE_AFTER		+	-	+	-
+ * _REMOVE_HEAD			+	-	+	-
+ * _REMOVE			s	+	s	+
+ * _SWAP			+	+	+	+
+ *
+ */
+#ifdef QUEUE_MACRO_DEBUG
+#warn Use QUEUE_MACRO_DEBUG_TRACE and/or QUEUE_MACRO_DEBUG_TRASH
+#define	QUEUE_MACRO_DEBUG_TRACE
+#define	QUEUE_MACRO_DEBUG_TRASH
+#endif
+
+#ifdef QUEUE_MACRO_DEBUG_TRACE
+/* Store the last 2 places the queue element or head was altered */
+struct qm_trace {
+	unsigned long	 lastline;
+	unsigned long	 prevline;
+	const char	*lastfile;
+	const char	*prevfile;
+};
+
+#define	TRACEBUF	struct qm_trace trace;
+#define	TRACEBUF_INITIALIZER	{ __LINE__, 0, __FILE__, NULL } ,
+
+#define	QMD_TRACE_HEAD(head) do {					\
+	(head)->trace.prevline = (head)->trace.lastline;		\
+	(head)->trace.prevfile = (head)->trace.lastfile;		\
+	(head)->trace.lastline = __LINE__;				\
+	(head)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#define	QMD_TRACE_ELEM(elem) do {					\
+	(elem)->trace.prevline = (elem)->trace.lastline;		\
+	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
+	(elem)->trace.lastline = __LINE__;				\
+	(elem)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#else	/* !QUEUE_MACRO_DEBUG_TRACE */
+#define	QMD_TRACE_ELEM(elem)
+#define	QMD_TRACE_HEAD(head)
+#define	TRACEBUF
+#define	TRACEBUF_INITIALIZER
+#endif	/* QUEUE_MACRO_DEBUG_TRACE */
+
+#ifdef QUEUE_MACRO_DEBUG_TRASH
+#define	TRASHIT(x)		do {(x) = (void *)-1;} while (0)
+#define	QMD_IS_TRASHED(x)	((x) == (void *)(intptr_t)-1)
+#else	/* !QUEUE_MACRO_DEBUG_TRASH */
+#define	TRASHIT(x)
+#define	QMD_IS_TRASHED(x)	0
+#endif	/* QUEUE_MACRO_DEBUG_TRASH */
+
+#if defined(QUEUE_MACRO_DEBUG_TRACE) || defined(QUEUE_MACRO_DEBUG_TRASH)
+#define	QMD_SAVELINK(name, link)	void **name = (void *)&(link)
+#else	/* !QUEUE_MACRO_DEBUG_TRACE && !QUEUE_MACRO_DEBUG_TRASH */
+#define	QMD_SAVELINK(name, link)
+#endif	/* QUEUE_MACRO_DEBUG_TRACE || QUEUE_MACRO_DEBUG_TRASH */
+
+#ifdef __cplusplus
+/*
+ * In C++ there can be structure lists and class lists:
+ */
+#define	QUEUE_TYPEOF(type) type
+#else
+#define	QUEUE_TYPEOF(type) struct type
+#endif
+
+/*
+ * Singly-linked List declarations.
+ */
+#define	SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+
+#define	SLIST_CLASS_ENTRY(type)						\
+struct {								\
+	class type *sle_next;		/* next element */		\
+}
+
+/*
+ * Singly-linked List functions.
+ */
+#if (defined(_KERNEL) && defined(INVARIANTS))
+#define	QMD_SLIST_CHECK_PREVPTR(prevp, elm) do {			\
+	if (*(prevp) != (elm))						\
+		panic("Bad prevptr *(%p) == %p != %p",			\
+		    (prevp), *(prevp), (elm));				\
+} while (0)
+#else
+#define	QMD_SLIST_CHECK_PREVPTR(prevp, elm)
+#endif
+
+#define SLIST_CONCAT(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *curelm = SLIST_FIRST(head1);		\
+	if (curelm == NULL) {						\
+		if ((SLIST_FIRST(head1) = SLIST_FIRST(head2)) != NULL)	\
+			SLIST_INIT(head2);				\
+	} else if (SLIST_FIRST(head2) != NULL) {			\
+		while (SLIST_NEXT(curelm, field) != NULL)		\
+			curelm = SLIST_NEXT(curelm, field);		\
+		SLIST_NEXT(curelm, field) = SLIST_FIRST(head2);		\
+		SLIST_INIT(head2);					\
+	}								\
+} while (0)
+
+#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
+
+#define	SLIST_FIRST(head)	((head)->slh_first)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var);							\
+	    (var) = SLIST_NEXT((var), field))
+
+#define	SLIST_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : SLIST_FIRST((head)));		\
+	    (var);							\
+	    (var) = SLIST_NEXT((var), field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	SLIST_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : SLIST_FIRST((head)));		\
+	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
+	for ((varp) = &SLIST_FIRST((head));				\
+	    ((var) = *(varp)) != NULL;					\
+	    (varp) = &SLIST_NEXT((var), field))
+
+#define	SLIST_INIT(head) do {						\
+	SLIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
+	SLIST_NEXT((slistelm), field) = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
+	SLIST_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_REMOVE(head, elm, type, field) do {			\
+	QMD_SAVELINK(oldnext, (elm)->field.sle_next);			\
+	if (SLIST_FIRST((head)) == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		QUEUE_TYPEOF(type) *curelm = SLIST_FIRST(head);		\
+		while (SLIST_NEXT(curelm, field) != (elm))		\
+			curelm = SLIST_NEXT(curelm, field);		\
+		SLIST_REMOVE_AFTER(curelm, field);			\
+	}								\
+	TRASHIT(*oldnext);						\
+} while (0)
+
+#define SLIST_REMOVE_AFTER(elm, field) do {				\
+	SLIST_NEXT(elm, field) =					\
+	    SLIST_NEXT(SLIST_NEXT(elm, field), field);			\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
+} while (0)
+
+#define	SLIST_REMOVE_PREVPTR(prevp, elm, field) do {			\
+	QMD_SLIST_CHECK_PREVPTR(prevp, elm);				\
+	*(prevp) = SLIST_NEXT(elm, field);				\
+	TRASHIT((elm)->field.sle_next);					\
+} while (0)
+
+#define SLIST_SWAP(head1, head2, type) do {				\
+	QUEUE_TYPEOF(type) *swap_first = SLIST_FIRST(head1);		\
+	SLIST_FIRST(head1) = SLIST_FIRST(head2);			\
+	SLIST_FIRST(head2) = swap_first;				\
+} while (0)
+
+/*
+ * Singly-linked Tail queue declarations.
+ */
+#define	STAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *stqh_first;/* first element */			\
+	struct type **stqh_last;/* addr of last next element */		\
+}
+
+#define	STAILQ_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *stqh_first;	/* first element */			\
+	class type **stqh_last;	/* addr of last next element */		\
+}
+
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
+}
+
+#define	STAILQ_CLASS_ENTRY(type)					\
+struct {								\
+	class type *stqe_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (0)
+
+#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
+
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+
+#define	STAILQ_FOREACH(var, head, field)				\
+	for((var) = STAILQ_FIRST((head));				\
+	   (var);							\
+	   (var) = STAILQ_NEXT((var), field))
+
+#define	STAILQ_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : STAILQ_FIRST((head)));		\
+	   (var);							\
+	   (var) = STAILQ_NEXT((var), field))
+
+#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = STAILQ_FIRST((head));				\
+	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	STAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)		\
+	for ((var) = ((var) ? (var) : STAILQ_FIRST((head)));		\
+	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	STAILQ_INIT(head) do {						\
+	STAILQ_FIRST((head)) = NULL;					\
+	(head)->stqh_last = &STAILQ_FIRST((head));			\
+} while (0)
+
+#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_NEXT((tqelm), field) = (elm);				\
+} while (0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	STAILQ_NEXT((elm), field) = NULL;				\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
+} while (0)
+
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	QMD_SAVELINK(oldnext, (elm)->field.stqe_next);			\
+	if (STAILQ_FIRST((head)) == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		QUEUE_TYPEOF(type) *curelm = STAILQ_FIRST(head);	\
+		while (STAILQ_NEXT(curelm, field) != (elm))		\
+			curelm = STAILQ_NEXT(curelm, field);		\
+		STAILQ_REMOVE_AFTER(head, curelm, field);		\
+	}								\
+	TRASHIT(*oldnext);						\
+} while (0)
+
+#define STAILQ_REMOVE_AFTER(head, elm, field) do {			\
+	if ((STAILQ_NEXT(elm, field) =					\
+	     STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+} while (0)
+
+#define	STAILQ_REMOVE_HEAD(head, field) do {				\
+	if ((STAILQ_FIRST((head)) =					\
+	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
+		(head)->stqh_last = &STAILQ_FIRST((head));		\
+} while (0)
+
+#define	STAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {			\
+	if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)	\
+		(head)->stqh_last = &STAILQ_FIRST((head));		\
+} while (0)
+
+#define STAILQ_SWAP(head1, head2, type) do {				\
+	QUEUE_TYPEOF(type) *swap_first = STAILQ_FIRST(head1);		\
+	QUEUE_TYPEOF(type) **swap_last = (head1)->stqh_last;		\
+	STAILQ_FIRST(head1) = STAILQ_FIRST(head2);			\
+	(head1)->stqh_last = (head2)->stqh_last;			\
+	STAILQ_FIRST(head2) = swap_first;				\
+	(head2)->stqh_last = swap_last;					\
+	if (STAILQ_EMPTY(head1))					\
+		(head1)->stqh_last = &STAILQ_FIRST(head1);		\
+	if (STAILQ_EMPTY(head2))					\
+		(head2)->stqh_last = &STAILQ_FIRST(head2);		\
+} while (0)
+
+
+/*
+ * List declarations.
+ */
+#define	LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define	LIST_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *lh_first;	/* first element */			\
+}
+
+#define	LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+#define	LIST_CLASS_ENTRY(type)						\
+struct {								\
+	class type *le_next;	/* next element */			\
+	class type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List functions.
+ */
+
+#if (defined(_KERNEL) && defined(INVARIANTS))
+/*
+ * QMD_LIST_CHECK_HEAD(LIST_HEAD *head, LIST_ENTRY NAME)
+ *
+ * If the list is non-empty, validates that the first element of the list
+ * points back at 'head.'
+ */
+#define	QMD_LIST_CHECK_HEAD(head, field) do {				\
+	if (LIST_FIRST((head)) != NULL &&				\
+	    LIST_FIRST((head))->field.le_prev !=			\
+	     &LIST_FIRST((head)))					\
+		panic("Bad list head %p first->prev != head", (head));	\
+} while (0)
+
+/*
+ * QMD_LIST_CHECK_NEXT(TYPE *elm, LIST_ENTRY NAME)
+ *
+ * If an element follows 'elm' in the list, validates that the next element
+ * points back at 'elm.'
+ */
+#define	QMD_LIST_CHECK_NEXT(elm, field) do {				\
+	if (LIST_NEXT((elm), field) != NULL &&				\
+	    LIST_NEXT((elm), field)->field.le_prev !=			\
+	     &((elm)->field.le_next))					\
+	     	panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+/*
+ * QMD_LIST_CHECK_PREV(TYPE *elm, LIST_ENTRY NAME)
+ *
+ * Validates that the previous element (or head of the list) points to 'elm.'
+ */
+#define	QMD_LIST_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.le_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_LIST_CHECK_HEAD(head, field)
+#define	QMD_LIST_CHECK_NEXT(elm, field)
+#define	QMD_LIST_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define LIST_CONCAT(head1, head2, type, field) do {			      \
+	QUEUE_TYPEOF(type) *curelm = LIST_FIRST(head1);			      \
+	if (curelm == NULL) {						      \
+		if ((LIST_FIRST(head1) = LIST_FIRST(head2)) != NULL) {	      \
+			LIST_FIRST(head2)->field.le_prev =		      \
+			    &LIST_FIRST((head1));			      \
+			LIST_INIT(head2);				      \
+		}							      \
+	} else if (LIST_FIRST(head2) != NULL) {				      \
+		while (LIST_NEXT(curelm, field) != NULL)		      \
+			curelm = LIST_NEXT(curelm, field);		      \
+		LIST_NEXT(curelm, field) = LIST_FIRST(head2);		      \
+		LIST_FIRST(head2)->field.le_prev = &LIST_NEXT(curelm, field); \
+		LIST_INIT(head2);					      \
+	}								      \
+} while (0)
+
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+
+#define	LIST_FIRST(head)	((head)->lh_first)
+
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = LIST_FIRST((head));				\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+
+#define	LIST_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : LIST_FIRST((head)));		\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST((head));				\
+	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	LIST_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : LIST_FIRST((head)));		\
+	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_NEXT(listelm, field);				\
+	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
+		LIST_NEXT((listelm), field)->field.le_prev =		\
+		    &LIST_NEXT((elm), field);				\
+	LIST_NEXT((listelm), field) = (elm);				\
+	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_PREV(listelm, field);				\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	LIST_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
+} while (0)
+
+#define	LIST_INSERT_HEAD(head, elm, field) do {				\
+	QMD_LIST_CHECK_HEAD((head), field);				\
+	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
+		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
+	LIST_FIRST((head)) = (elm);					\
+	(elm)->field.le_prev = &LIST_FIRST((head));			\
+} while (0)
+
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+
+#define	LIST_PREV(elm, head, type, field)			\
+	((elm)->field.le_prev == &LIST_FIRST((head)) ? NULL :	\
+	    __containerof((elm)->field.le_prev,			\
+	    QUEUE_TYPEOF(type), field.le_next))
+
+#define	LIST_REMOVE(elm, field) do {					\
+	QMD_SAVELINK(oldnext, (elm)->field.le_next);			\
+	QMD_SAVELINK(oldprev, (elm)->field.le_prev);			\
+	QMD_LIST_CHECK_NEXT(elm, field);				\
+	QMD_LIST_CHECK_PREV(elm, field);				\
+	if (LIST_NEXT((elm), field) != NULL)				\
+		LIST_NEXT((elm), field)->field.le_prev = 		\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
+	TRASHIT(*oldnext);						\
+	TRASHIT(*oldprev);						\
+} while (0)
+
+#define LIST_SWAP(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *swap_tmp = LIST_FIRST(head1);		\
+	LIST_FIRST((head1)) = LIST_FIRST((head2));			\
+	LIST_FIRST((head2)) = swap_tmp;					\
+	if ((swap_tmp = LIST_FIRST((head1))) != NULL)			\
+		swap_tmp->field.le_prev = &LIST_FIRST((head1));		\
+	if ((swap_tmp = LIST_FIRST((head2))) != NULL)			\
+		swap_tmp->field.le_prev = &LIST_FIRST((head2));		\
+} while (0)
+
+/*
+ * Tail queue declarations.
+ */
+#define	TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+	TRACEBUF							\
+}
+
+#define	TAILQ_CLASS_HEAD(name, type)					\
+struct name {								\
+	class type *tqh_first;	/* first element */			\
+	class type **tqh_last;	/* addr of last next element */		\
+	TRACEBUF							\
+}
+
+#define	TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first, TRACEBUF_INITIALIZER }
+
+#define	TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+	TRACEBUF							\
+}
+
+#define	TAILQ_CLASS_ENTRY(type)						\
+struct {								\
+	class type *tqe_next;	/* next element */			\
+	class type **tqe_prev;	/* address of previous next element */	\
+	TRACEBUF							\
+}
+
+/*
+ * Tail queue functions.
+ */
+#if (defined(_KERNEL) && defined(INVARIANTS))
+/*
+ * QMD_TAILQ_CHECK_HEAD(TAILQ_HEAD *head, TAILQ_ENTRY NAME)
+ *
+ * If the tailq is non-empty, validates that the first element of the tailq
+ * points back at 'head.'
+ */
+#define	QMD_TAILQ_CHECK_HEAD(head, field) do {				\
+	if (!TAILQ_EMPTY(head) &&					\
+	    TAILQ_FIRST((head))->field.tqe_prev !=			\
+	     &TAILQ_FIRST((head)))					\
+		panic("Bad tailq head %p first->prev != head", (head));	\
+} while (0)
+
+/*
+ * QMD_TAILQ_CHECK_TAIL(TAILQ_HEAD *head, TAILQ_ENTRY NAME)
+ *
+ * Validates that the tail of the tailq is a pointer to pointer to NULL.
+ */
+#define	QMD_TAILQ_CHECK_TAIL(head, field) do {				\
+	if (*(head)->tqh_last != NULL)					\
+	    	panic("Bad tailq NEXT(%p->tqh_last) != NULL", (head)); 	\
+} while (0)
+
+/*
+ * QMD_TAILQ_CHECK_NEXT(TYPE *elm, TAILQ_ENTRY NAME)
+ *
+ * If an element follows 'elm' in the tailq, validates that the next element
+ * points back at 'elm.'
+ */
+#define	QMD_TAILQ_CHECK_NEXT(elm, field) do {				\
+	if (TAILQ_NEXT((elm), field) != NULL &&				\
+	    TAILQ_NEXT((elm), field)->field.tqe_prev !=			\
+	     &((elm)->field.tqe_next))					\
+		panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+/*
+ * QMD_TAILQ_CHECK_PREV(TYPE *elm, TAILQ_ENTRY NAME)
+ *
+ * Validates that the previous element (or head of the tailq) points to 'elm.'
+ */
+#define	QMD_TAILQ_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.tqe_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_TAILQ_CHECK_HEAD(head, field)
+#define	QMD_TAILQ_CHECK_TAIL(head, headname)
+#define	QMD_TAILQ_CHECK_NEXT(elm, field)
+#define	QMD_TAILQ_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define	TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+		QMD_TRACE_HEAD(head1);					\
+		QMD_TRACE_HEAD(head2);					\
+	}								\
+} while (0)
+
+#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
+
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+
+#define	TAILQ_FOREACH_FROM(var, head, field)				\
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));		\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_FROM_SAFE(var, head, field, tvar)			\
+	for ((var) = ((var) ? (var) : TAILQ_FIRST((head)));		\
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_FROM(var, head, headname, field)		\
+	for ((var) = ((var) ? (var) : TAILQ_LAST((head), headname));	\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_REVERSE_FROM_SAFE(var, head, headname, field, tvar) \
+	for ((var) = ((var) ? (var) : TAILQ_LAST((head), headname));	\
+	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
+	    (var) = (tvar))
+
+#define	TAILQ_INIT(head) do {						\
+	TAILQ_FIRST((head)) = NULL;					\
+	(head)->tqh_last = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+} while (0)
+
+#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	QMD_TAILQ_CHECK_NEXT(listelm, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    &TAILQ_NEXT((elm), field);				\
+	else {								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	TAILQ_NEXT((listelm), field) = (elm);				\
+	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&(listelm)->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_TAILQ_CHECK_PREV(listelm, field);				\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	TAILQ_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&(listelm)->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_HEAD(head, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
+		TAILQ_FIRST((head))->field.tqe_prev =			\
+		    &TAILQ_NEXT((elm), field);				\
+	else								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+	TAILQ_FIRST((head)) = (elm);					\
+	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_TAIL(head, field);				\
+	TAILQ_NEXT((elm), field) = NULL;				\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+/*
+ * The FAST function is fast in that it causes no data access other
+ * then the access to the head. The standard LAST function above
+ * will cause a data access of both the element you want and
+ * the previous element. FAST is very useful for instances when
+ * you may want to prefetch the last data element.
+ */
+#define	TAILQ_LAST_FAST(head, type, field)			\
+    (TAILQ_EMPTY(head) ? NULL : __containerof((head)->tqh_last, QUEUE_TYPEOF(type), field.tqe_next))
+
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	QMD_SAVELINK(oldnext, (elm)->field.tqe_next);			\
+	QMD_SAVELINK(oldprev, (elm)->field.tqe_prev);			\
+	QMD_TAILQ_CHECK_NEXT(elm, field);				\
+	QMD_TAILQ_CHECK_PREV(elm, field);				\
+	if ((TAILQ_NEXT((elm), field)) != NULL)				\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    (elm)->field.tqe_prev;				\
+	else {								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
+	TRASHIT(*oldnext);						\
+	TRASHIT(*oldprev);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define TAILQ_SWAP(head1, head2, type, field) do {			\
+	QUEUE_TYPEOF(type) *swap_first = (head1)->tqh_first;		\
+	QUEUE_TYPEOF(type) **swap_last = (head1)->tqh_last;		\
+	(head1)->tqh_first = (head2)->tqh_first;			\
+	(head1)->tqh_last = (head2)->tqh_last;				\
+	(head2)->tqh_first = swap_first;				\
+	(head2)->tqh_last = swap_last;					\
+	if ((swap_first = (head1)->tqh_first) != NULL)			\
+		swap_first->field.tqe_prev = &(head1)->tqh_first;	\
+	else								\
+		(head1)->tqh_last = &(head1)->tqh_first;		\
+	if ((swap_first = (head2)->tqh_first) != NULL)			\
+		swap_first->field.tqe_prev = &(head2)->tqh_first;	\
+	else								\
+		(head2)->tqh_last = &(head2)->tqh_first;		\
+} while (0)
+
+#ifdef _KERNEL
+
+/*
+ * XXX insque() and remque() are an old way of handling certain queues.
+ * They bogusly assumes that all queue heads look alike.
+ */
+
+struct quehead {
+	struct quehead *qh_link;
+	struct quehead *qh_rlink;
+};
+
+#ifdef	__GNUC__
+
+static __inline void
+insque(void *a, void *b)
+{
+	struct quehead *element = (struct quehead *)a,
+		 *head = (struct quehead *)b;
+
+	element->qh_link = head->qh_link;
+	element->qh_rlink = head;
+	head->qh_link = element;
+	element->qh_link->qh_rlink = element;
+}
+
+static __inline void
+remque(void *a)
+{
+	struct quehead *element = (struct quehead *)a;
+
+	element->qh_link->qh_rlink = element->qh_rlink;
+	element->qh_rlink->qh_link = element->qh_link;
+	element->qh_rlink = 0;
+}
+
+#else /* !__GNUC__ */
+
+void	insque(void *a, void *b);
+void	remque(void *a);
+
+#endif /* __GNUC__ */
+
+#endif /* _KERNEL */
+
+#endif /* !_SYS_QUEUE_H_ */


