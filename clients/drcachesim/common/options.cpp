/* **********************************************************
 * Copyright (c) 2015-2019 Google, Inc.  All rights reserved.
 * **********************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/* shared options for both the frontend and the client */

#include <string>
#include "droption.h"
#include "options.h"

droption_t<bool> op_offline(
    DROPTION_SCOPE_ALL, "offline", false, "Store trace files for offline analysis",
    "By default, traces are processed online, sent over a pipe to a simulator.  "
    "If this option is enabled, trace data is instead written to files in -outdir "
    "for later offline analysis.  No simulator is executed.");

droption_t<std::string> op_ipc_name(
    DROPTION_SCOPE_ALL, "ipc_name", "drcachesimpipe", "Name of named pipe",
    "For online tracing and simulation (the default, unless -offline is requested), "
    "specifies the name of the named pipe used to communicate between the target "
    "application processes and the caching device simulator.  On Linux this can include "
    "an absolute path (if it doesn't, a default temp directory "
    "will be used).  A unique name must be chosen "
    "for each instance of the simulator being run at any one time.  On Windows, the name "
    "is limited to 247 characters.");

droption_t<std::string> op_outdir(
    DROPTION_SCOPE_ALL, "outdir", ".", "Target directory for offline trace files",
    "For the offline analysis mode (when -offline is requested), specifies the path "
    "to a directory where per-thread trace files will be written.");

droption_t<std::string> op_indir(
    DROPTION_SCOPE_ALL, "indir", "", "Input directory of offline trace files",
    "After a trace file is produced via -offline into -outdir, it can be passed to the "
    "simulator via this flag pointing at the subdirectory created in -outdir. "
    "The -offline tracing produces raw data files which are converted into final "
    "trace files on the first execution with -indir.  The raw files can also be manually "
    "converted using the drraw2trace tool.  Legacy single trace files with all threads "
    "interleaved into one are not supported with this option: use -infile instead.");

droption_t<std::string> op_infile(
    DROPTION_SCOPE_ALL, "infile", "", "Offline legacy file for input to the simulator",
    "Directs the simulator to use a single all-threads-interleaved-into-one trace file. "
    "This is a legacy file format that is no longer produced.");

droption_t<int> op_jobs(
    DROPTION_SCOPE_ALL, "jobs", -1, "Number of parallel jobs",
    "By default, both post-processing of offline raw trace files and analysis of trace "
    "files is parallelized.  This option controls the number of concurrent jobs.  0 "
    "disables concurrency and uses a single thread to perform all operations.  A "
    "negative value sets the job count to the number of hardware threads, "
    "with a cap of 16.");

droption_t<std::string> op_module_file(
    DROPTION_SCOPE_ALL, "module_file", "", "Path to modules.log for opcode_mix tool",
    "The opcode_mix tool needs the modules.log file (generated by the offline "
    "post-processing step in the raw/ subdirectory) in addition to the trace file. "
    "If the file is named modules.log and is in the same directory as the trace file, "
    "or a raw/ subdirectory below the trace file, this parameter can be omitted.");

droption_t<unsigned int> op_num_cores(DROPTION_SCOPE_FRONTEND, "cores", 4,
                                      "Number of cores",
                                      "Specifies the number of cores to simulate.");

droption_t<unsigned int> op_line_size(
    DROPTION_SCOPE_FRONTEND, "line_size", 64, "Cache line size",
    "Specifies the cache line size, which is assumed to be identical for L1 and L2 "
    "caches.  Must be a power of 2.");

droption_t<bytesize_t> op_L1I_size(
    DROPTION_SCOPE_FRONTEND, "L1I_size", 32 * 1024U, "Instruction cache total size",
    "Specifies the total size of each L1 instruction cache.  Must be a power of 2 "
    "and a multiple of -line_size.");

droption_t<bytesize_t>
    op_L1D_size(DROPTION_SCOPE_FRONTEND, "L1D_size", bytesize_t(32 * 1024),
                "Data cache total size",
                "Specifies the total size of each L1 data cache.  Must be a power of 2 "
                "and a multiple of -line_size.");

droption_t<unsigned int> op_L1I_assoc(
    DROPTION_SCOPE_FRONTEND, "L1I_assoc", 8, "Instruction cache associativity",
    "Specifies the associativity of each L1 instruction cache.  Must be a power of 2.");

droption_t<unsigned int> op_L1D_assoc(
    DROPTION_SCOPE_FRONTEND, "L1D_assoc", 8, "Data cache associativity",
    "Specifies the associativity of each L1 data cache.  Must be a power of 2.");

droption_t<bytesize_t> op_LL_size(DROPTION_SCOPE_FRONTEND, "LL_size", 8 * 1024 * 1024,
                                  "Last-level cache total size",
                                  "Specifies the total size of the unified last-level "
                                  "(L2) cache.  Must be a power of 2 "
                                  "and a multiple of -line_size.");

droption_t<unsigned int>
    op_LL_assoc(DROPTION_SCOPE_FRONTEND, "LL_assoc", 16, "Last-level cache associativity",
                "Specifies the associativity of the unified last-level (L2) cache.  "
                "Must be a power of 2.");

droption_t<std::string> op_LL_miss_file(
    DROPTION_SCOPE_FRONTEND, "LL_miss_file", "",
    "Path for dumping LLC misses or prefetching hints",
    "If non-empty, when running the cache simulator, requests that "
    "every last-level cache miss be written to a file at the specified path. Each miss "
    "is written in text format as a <program counter, address> pair. If this tool is "
    "linked with zlib, the file is written in gzip-compressed format. If non-empty, when "
    "running the cache miss analyzer, requests that prefetching hints based on the miss "
    "analysis be written to the specified file. Each hint is written in text format as a "
    "<program counter, stride, locality level> tuple.");

droption_t<bool> op_L0_filter(
    DROPTION_SCOPE_CLIENT, "L0_filter", false,
    "Filter out zero-level hits during tracing",
    "Filters out instruction and data hits in a 'zero-level' cache during tracing "
    "itself, "
    "shrinking the final trace to only contain instruction and data accesses that miss "
    "in "
    "this initial cache.  This cache is direct-mapped with sizes equal to -L0I_size and "
    "-L0D_size.  It uses virtual addresses regardless of -use_physical.");

droption_t<bytesize_t> op_L0I_size(
    DROPTION_SCOPE_CLIENT, "L0I_size", 32 * 1024U,
    "If -L0_filter, filter out instruction hits during tracing",
    "Specifies the size of the 'zero-level' instruction cache for -L0_filter.  "
    "Must be a power of 2 and a multiple of -line_size, unless it is set to 0, "
    "which disables instruction fetch entries from appearing in the trace.");

droption_t<bytesize_t> op_L0D_size(
    DROPTION_SCOPE_CLIENT, "L0D_size", 32 * 1024U,
    "If -L0_filter, filter out data hits during tracing",
    "Specifies the size of the 'zero-level' data cache for -L0_filter.  "
    "Must be a power of 2 and a multiple of -line_size, unless it is set to 0, "
    "which disables data entries from appearing in the trace.");

droption_t<bool> op_use_physical(
    DROPTION_SCOPE_CLIENT, "use_physical", false, "Use physical addresses if possible",
    "If available, the default virtual addresses will be translated to physical.  "
    "This is not possible from user mode on all platforms.");

droption_t<unsigned int> op_virt2phys_freq(
    DROPTION_SCOPE_CLIENT, "virt2phys_freq", 0, "Frequency of physical mapping refresh",
    "This option only applies if -use_physical is enabled.  The virtual to physical "
    "mapping is cached for performance reasons, yet the underlying mapping can change "
    "without notice.  This option controls the frequency with which the cached value is "
    "ignored in order to re-access the actual mapping and ensure accurate results.  "
    "The units are the number of memory accesses per forced access.  A value of 0 "
    "uses the cached values for the entire application execution.");

droption_t<bool> op_cpu_scheduling(
    DROPTION_SCOPE_CLIENT, "cpu_scheduling", false,
    "Map threads to cores matching recorded cpu execution",
    "By default, the simulator schedules threads to simulated cores in a static "
    "round-robin fashion.  This option causes the scheduler to instead use the recorded "
    "cpu that each thread executed on (at a granularity of the trace buffer size) "
    "for scheduling, mapping traced cpu's to cores and running each segment of each "
    "thread "
    "on the core that owns the recorded cpu for that segment.");

droption_t<bytesize_t> op_max_trace_size(
    DROPTION_SCOPE_CLIENT, "max_trace_size", 0,
    "Cap on the raw trace size for each thread",
    "If non-zero, this sets a maximum size on the amount of raw trace data gathered "
    "for each thread.  This is not an exact limit: it may be exceeded by the size "
    "of one internal buffer.  Once reached, instrumentation continues for that thread, "
    "but no further data is recorded.");

droption_t<bytesize_t> op_trace_after_instrs(
    DROPTION_SCOPE_CLIENT, "trace_after_instrs", 0,
    "Do not start tracing until N instructions",
    "If non-zero, this causes tracing to be suppressed until this many dynamic "
    "instruction "
    "executions are observed.  At that point, regular tracing is put into place.  Use "
    "-max_trace_size to set a limit on the subsequent trace length.");

droption_t<bytesize_t> op_exit_after_tracing(
    DROPTION_SCOPE_CLIENT, "exit_after_tracing", 0,
    "Exit the process after tracing N references",
    "If non-zero, after tracing the specified number of references, the process is "
    "exited with an exit code of 0.  The reference count is approximate.");

droption_t<bool> op_online_instr_types(
    DROPTION_SCOPE_CLIENT, "online_instr_types", false,
    "Whether online traces should distinguish instr types",
    "By default, offline traces include some information on the types of instructions, "
    "branches in particular.  For online traces, this comes at a performance cost, so "
    "it is turned off by default.");

droption_t<std::string> op_replace_policy(
    DROPTION_SCOPE_FRONTEND, "replace_policy", REPLACE_POLICY_LRU,
    "Cache replacement policy (LRU, LFU, FIFO)",
    "Specifies the replacement policy for "
    "caches. Supported policies: LRU (Least Recently Used), LFU (Least Frequently Used), "
    "FIFO (First-In-First-Out).");

droption_t<std::string> op_data_prefetcher(
    DROPTION_SCOPE_FRONTEND, "data_prefetcher", PREFETCH_POLICY_NEXTLINE,
    "Hardware data prefetcher policy (nextline, none)",
    "Specifies the hardware data "
    "prefetcher policy.  The currently supported policies are 'nextline' (fetch the "
    "subsequent cache line) and 'none' (disables hardware prefetching).  The prefetcher "
    "is located between the L1D and LL caches.");

droption_t<bytesize_t> op_page_size(DROPTION_SCOPE_FRONTEND, "page_size",
                                    bytesize_t(4 * 1024), "Virtual/physical page size",
                                    "Specifies the virtual/physical page size.");

droption_t<unsigned int> op_TLB_L1I_entries(
    DROPTION_SCOPE_FRONTEND, "TLB_L1I_entries", 32,
    "Number of entries in instruction TLB",
    "Specifies the number of entries in each L1 instruction TLB.  Must be a power of 2.");

droption_t<unsigned int> op_TLB_L1D_entries(
    DROPTION_SCOPE_FRONTEND, "TLB_L1D_entries", 32, "Number of entries in data TLB",
    "Specifies the number of entries in each L1 data TLB.  Must be a power of 2.");

droption_t<unsigned int> op_TLB_L1I_assoc(
    DROPTION_SCOPE_FRONTEND, "TLB_L1I_assoc", 32, "Instruction TLB associativity",
    "Specifies the associativity of each L1 instruction TLB.  Must be a power of 2.");

droption_t<unsigned int> op_TLB_L1D_assoc(
    DROPTION_SCOPE_FRONTEND, "TLB_L1D_assoc", 32, "Data TLB associativity",
    "Specifies the associativity of each L1 data TLB.  Must be a power of 2.");

droption_t<unsigned int> op_TLB_L2_entries(
    DROPTION_SCOPE_FRONTEND, "TLB_L2_entries", 1024, "Number of entries in L2 TLB",
    "Specifies the number of entries in each unified L2 TLB.  Must be a power of 2.");

droption_t<unsigned int> op_TLB_L2_assoc(
    DROPTION_SCOPE_FRONTEND, "TLB_L2_assoc", 4, "L2 TLB associativity",
    "Specifies the associativity of each unified L2 TLB.  Must be a power of 2.");

droption_t<std::string>
    op_TLB_replace_policy(DROPTION_SCOPE_FRONTEND, "TLB_replace_policy",
                          REPLACE_POLICY_LFU, "TLB replacement policy",
                          "Specifies the replacement policy for TLBs. "
                          "Supported policies: LFU (Least Frequently Used).");

droption_t<std::string> op_simulator_type(DROPTION_SCOPE_FRONTEND, "simulator_type",
                                          CPU_CACHE,
                                          "Simulator type (" CPU_CACHE ", " MISS_ANALYZER
                                          ", " TLB ", " REUSE_DIST ", " REUSE_TIME
                                          ", " HISTOGRAM ", or " BASIC_COUNTS ").",
                                          "Specifies the type of the simulator. "
                                          "Supported types: " CPU_CACHE ", " MISS_ANALYZER
                                          ", " TLB ", " REUSE_DIST ", " REUSE_TIME
                                          ", " HISTOGRAM "or " BASIC_COUNTS ".");

droption_t<unsigned int> op_verbose(DROPTION_SCOPE_ALL, "verbose", 0, 0, 64,
                                    "Verbosity level",
                                    "Verbosity level for notifications.");

#ifdef DEBUG
droption_t<bool> op_test_mode(DROPTION_SCOPE_ALL, "test_mode", false, "Run sanity tests",
                              "Run extra analyses for sanity checks on the trace.");
#endif

droption_t<std::string> op_dr_root(DROPTION_SCOPE_FRONTEND, "dr", "",
                                   "Path to DynamoRIO root directory",
                                   "Specifies the path of the DynamoRIO root directory.");

droption_t<bool> op_dr_debug(
    DROPTION_SCOPE_FRONTEND, "dr_debug", false, "Use DynamoRIO debug build",
    "Requests use of the debug build of DynamoRIO rather than the release build.");

droption_t<std::string> op_dr_ops(DROPTION_SCOPE_FRONTEND, "dr_ops", "",
                                  "Options to pass to DynamoRIO",
                                  "Specifies the options to pass to DynamoRIO.");

droption_t<std::string> op_tracer(DROPTION_SCOPE_FRONTEND, "tracer", "",
                                  "Path to the tracer",
                                  "The full path to the tracer library.");

droption_t<std::string> op_tracer_ops(
    DROPTION_SCOPE_FRONTEND, "tracer_ops",
    DROPTION_FLAG_SWEEP | DROPTION_FLAG_ACCUMULATE | DROPTION_FLAG_INTERNAL, "",
    "(For internal use: sweeps up tracer options)",
    "This is an internal option that sweeps up other options to pass to the tracer.");

droption_t<bytesize_t>
    op_skip_refs(DROPTION_SCOPE_FRONTEND, "skip_refs", 0,
                 "Number of memory references to skip",
                 "Specifies the number of references to skip "
                 "in the beginning of the application execution. "
                 "These memory references are dropped instead of being simulated.");

droption_t<bytesize_t> op_warmup_refs(
    DROPTION_SCOPE_FRONTEND, "warmup_refs", 0,
    "Number of memory references to warm caches up",
    "Specifies the number of memory references to warm up caches before simulation. "
    "The warmup references come after the skipped references and before the "
    "simulated references. This flag is incompatible with warmup_fraction.");

droption_t<double> op_warmup_fraction(
    DROPTION_SCOPE_FRONTEND, "warmup_fraction", 0.0, 0.0, 1.0,
    "Fraction of last level cache blocks to be loaded as warm up",
    "Specifies the fraction of last level cache blocks to be loaded such that the "
    "cache is considered to be warmed up before simulation. The warmup fraction "
    "is computed after the skipped references and before simulated references. "
    "This flag is incompatible with warmup_refs.");

droption_t<bytesize_t>
    op_sim_refs(DROPTION_SCOPE_FRONTEND, "sim_refs", bytesize_t(1ULL << 63),
                "Number of memory references to simulate",
                "Specifies the number of memory references to simulate. "
                "The simulated references come after the skipped and warmup references, "
                "and the references following the simulated ones are dropped.");

droption_t<std::string>
    op_view_syntax(DROPTION_SCOPE_FRONTEND, "view_syntax", "att",
                   "Syntax to use for disassembly.",
                   "Specifies the syntax to use when viewing disassembled offline traces."
                   "The option can be set to one of att (default), intel, dr and arm."
                   "An invalid specification falls back to the default.");

droption_t<std::string>
    op_config_file(DROPTION_SCOPE_FRONTEND, "config_file", "",
                   "Cache hierarchy configuration file",
                   "The full path to the cache hierarchy configuration file.");

// XXX: if we separate histogram + reuse_distance we should move this with them.
droption_t<unsigned int>
    op_report_top(DROPTION_SCOPE_FRONTEND, "report_top", 10,
                  "Number of top results to be reported",
                  "Specifies the number of top results to be reported.");

// XXX: if we separate histogram + reuse_distance we should move these with them.
droption_t<unsigned int> op_reuse_distance_threshold(
    DROPTION_SCOPE_FRONTEND, "reuse_distance_threshold", 100,
    "The reuse distance threshold for reporting the distant repeated references.",
    "Specifies the reuse distance threshold for reporting the distant repeated "
    "references. "
    "A reference is a distant repeated reference if the distance to the previous "
    "reference"
    " on the same cache line exceeds the threshold.");
droption_t<bool> op_reuse_distance_histogram(
    DROPTION_SCOPE_FRONTEND, "reuse_distance_histogram", false,
    "Print the entire reuse distance histogram.",
    "By default only the mean, median, and standard deviation of the reuse distances "
    "are reported.  This option prints out the full histogram of reuse distances.");
droption_t<unsigned int> op_reuse_skip_dist(
    DROPTION_SCOPE_FRONTEND, "reuse_skip_dist", 500,
    "For performance tuning: distance between skip nodes.",
    "Specifies the distance between nodes in the skip list.  For optimal performance, "
    "set this to a value close to the estimated average reuse distance of the dataset.");
droption_t<bool> op_reuse_verify_skip(
    DROPTION_SCOPE_FRONTEND, "reuse_verify_skip", false,
    "Use full list walks to verify the skip list results.",
    "Verifies every skip list-calculated reuse distance with a full list walk. "
    "This incurs significant additional overhead.  This option is only available "
    "in debug builds.");

#define OP_RECORD_FUNC_ITEM_SEP "&"
// XXX i#3048: replace function return address with function callstack
// XXX i#3048: add a section to drcachesim.dox.in on function tracing
droption_t<std::string> op_record_function(
    DROPTION_SCOPE_ALL, "record_function", DROPTION_FLAG_ACCUMULATE,
    OP_RECORD_FUNC_ITEM_SEP, "",
    "Record invocations trace for the specified function(s).",
    "Record invocations trace for the specified function(s) in the option"
    " value. Default value is empty. The value should fit this format:"
    " function_name|function_id|func_args_num"
    " (e.g., -record_function \"memset|10|3\"). The trace would contain"
    " information for function return address, function argument value(s),"
    " and function return value. We only record pointer-sized arguments and"
    " return value. The trace is labeled with the function_id via an ID entry"
    " prior to each set of value entries."
    " If the target function is in the dynamic symbol table, then the function_name"
    " should be a mangled name (e.g. \"_Znwm\" for \"operator new\", \"_ZdlPv\" for"
    " \"operator delete\"). Otherwise, the function_name should be a demangled name."
    " Recording multiple functions can be achieved by using the separator"
    " \"" OP_RECORD_FUNC_ITEM_SEP
    "\" (e.g., -record_function \"memset|10|3" OP_RECORD_FUNC_ITEM_SEP
    "memcpy|11|3\"), or"
    " specifying multiple -record_function options (e.g., -record_function"
    " \"memset|10|3\" -record_function \"memcpy|11|3\")."
    " Note that the provided function id should be unique, and not collide with"
    " existing heap functions (see -record_heap_value) if -record_heap"
    " option is enabled.");
droption_t<bool> op_record_heap(
    DROPTION_SCOPE_ALL, "record_heap", false,
    "Enable recording a trace for the defined heap functions.",
    "It is a convenience option to enable recording a trace for the defined heap"
    " functions in -record_heap_value. Specifying this option is equivalent to"
    " -record_function [heap_functions], where [heap_functions] is"
    " the value in -record_heap_value.");
droption_t<std::string> op_record_heap_value(
    DROPTION_SCOPE_ALL, "record_heap_value", DROPTION_FLAG_ACCUMULATE,
    OP_RECORD_FUNC_ITEM_SEP,
    "malloc|0|1" OP_RECORD_FUNC_ITEM_SEP "free|1|1" OP_RECORD_FUNC_ITEM_SEP
    "tc_malloc|2|1" OP_RECORD_FUNC_ITEM_SEP "tc_free|3|1" OP_RECORD_FUNC_ITEM_SEP
    "__libc_malloc|4|1" OP_RECORD_FUNC_ITEM_SEP "__libc_free|5|1" OP_RECORD_FUNC_ITEM_SEP
    "calloc|6|2",
    "Functions recorded by -record_heap",
    "Functions recorded by -record_heap. The option value should fit the same"
    " format required by -record_function. These functions will not"
    " be traced unless -record_heap is specified.");
droption_t<unsigned int> op_miss_count_threshold(
    DROPTION_SCOPE_FRONTEND, "miss_count_threshold", 50000,
    "For cache miss analysis: minimum LLC miss count for a load to be eligible for "
    "analysis.",
    "Specifies the minimum number of LLC misses of a load for it to be eligible for "
    "analysis in search of patterns in the miss address stream.");
droption_t<double> op_miss_frac_threshold(
    DROPTION_SCOPE_FRONTEND, "miss_frac_threshold", 0.005,
    "For cache miss analysis: minimum LLC miss fraction for a load to be eligible for "
    "analysis.",
    "Specifies the minimum fraction of LLC misses of a load (from all misses) for it to "
    "be eligible for analysis in search of patterns in the miss address stream.");
droption_t<double> op_confidence_threshold(
    DROPTION_SCOPE_FRONTEND, "confidence_threshold", 0.75,
    "For cache miss analysis: minimum confidence threshold of a pattern to be printed "
    "out.",
    "Specifies the minimum confidence to include a discovered pattern in the output "
    "results. Confidence in a discovered pattern for a load instruction is calculated "
    "as the fraction of the load's misses with the discovered pattern over all the "
    "load's misses.");
